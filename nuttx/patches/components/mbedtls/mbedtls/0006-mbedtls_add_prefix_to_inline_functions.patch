diff --git a/include/mbedtls/ssl.h b/include/mbedtls/ssl.h
index 2e3203a2215499b6fb9de6296aca918e22d38760..9b43e83b598b81cd828bea29a38da9d071c77cdf 100644
--- a/include/mbedtls/ssl.h
+++ b/include/mbedtls/ssl.h
@@ -1138,7 +1138,7 @@ typedef struct {
  * Use_srtp extension protection profiles values as defined in
  * http://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml
  *
- * Reminder: if this list is expanded mbedtls_ssl_check_srtp_profile_value
+ * Reminder: if this list is expanded esp_mbedtls_ssl_check_srtp_profile_value
  * must be updated too.
  */
 #define MBEDTLS_TLS_SRTP_AES128_CM_HMAC_SHA1_80     ((uint16_t) 0x0001)
diff --git a/library/aes.c b/library/aes.c
index f2cff518401bfa0148327b2132c2c0485bdef1af..9a3b81622e766f3862c9e1bf794000325b36bfa2 100644
--- a/library/aes.c
+++ b/library/aes.c
@@ -1076,7 +1076,7 @@ int esp_mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,
                 goto exit;
             }
 
-            mbedtls_xor(output, output, iv, 16);
+            esp_mbedtls_xor(output, output, iv, 16);
 
             memcpy(iv, temp, 16);
 
@@ -1086,7 +1086,7 @@ int esp_mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,
         }
     } else {
         while (length > 0) {
-            mbedtls_xor(output, input, iv, 16);
+            esp_mbedtls_xor(output, input, iv, 16);
 
             ret = esp_mbedtls_aes_crypt_ecb(ctx, mode, output, output);
             if (ret != 0) {
@@ -1182,14 +1182,14 @@ int esp_mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,
             esp_mbedtls_gf128mul_x_ble(tweak, tweak);
         }
 
-        mbedtls_xor(tmp, input, tweak, 16);
+        esp_mbedtls_xor(tmp, input, tweak, 16);
 
         ret = esp_mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
         if (ret != 0) {
             return ret;
         }
 
-        mbedtls_xor(output, tmp, tweak, 16);
+        esp_mbedtls_xor(output, tmp, tweak, 16);
 
         /* Update the tweak for the next block. */
         esp_mbedtls_gf128mul_x_ble(tweak, tweak);
@@ -1215,11 +1215,11 @@ int esp_mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,
         }
 
         /* Copy the remainder of the input for this final round. */
-        mbedtls_xor(tmp, input, t, leftover);
+        esp_mbedtls_xor(tmp, input, t, leftover);
 
         /* Copy ciphertext bytes from the previous block for input in this
          * round. */
-        mbedtls_xor(tmp + i, prev_output + i, t + i, 16 - i);
+        esp_mbedtls_xor(tmp + i, prev_output + i, t + i, 16 - i);
 
         ret = esp_mbedtls_aes_crypt_ecb(&ctx->crypt, mode, tmp, tmp);
         if (ret != 0) {
@@ -1228,7 +1228,7 @@ int esp_mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,
 
         /* Write the result back to the previous block, overriding the previous
          * output we copied. */
-        mbedtls_xor(prev_output, tmp, t, 16);
+        esp_mbedtls_xor(prev_output, tmp, t, 16);
     }
 
     return 0;
diff --git a/library/alignment.h b/library/alignment.h
index a518a8a3ae430acf7657178794133ed8c6421416..b9a50d8758a876b02bf5b0969f6c55085a5423be 100644
--- a/library/alignment.h
+++ b/library/alignment.h
@@ -53,7 +53,7 @@
  * \param   p pointer to 2 bytes of data
  * \return  Data at the given address
  */
-inline uint16_t mbedtls_get_unaligned_uint16(const void *p)
+inline uint16_t esp_mbedtls_get_unaligned_uint16(const void *p)
 {
     uint16_t r;
     memcpy(&r, p, sizeof(r));
@@ -67,7 +67,7 @@ inline uint16_t mbedtls_get_unaligned_uint16(const void *p)
  * \param   p pointer to 2 bytes of data
  * \param   x data to write
  */
-inline void mbedtls_put_unaligned_uint16(void *p, uint16_t x)
+inline void esp_mbedtls_put_unaligned_uint16(void *p, uint16_t x)
 {
     memcpy(p, &x, sizeof(x));
 }
@@ -79,7 +79,7 @@ inline void mbedtls_put_unaligned_uint16(void *p, uint16_t x)
  * \param   p pointer to 4 bytes of data
  * \return  Data at the given address
  */
-inline uint32_t mbedtls_get_unaligned_uint32(const void *p)
+inline uint32_t esp_mbedtls_get_unaligned_uint32(const void *p)
 {
     uint32_t r;
     memcpy(&r, p, sizeof(r));
@@ -93,7 +93,7 @@ inline uint32_t mbedtls_get_unaligned_uint32(const void *p)
  * \param   p pointer to 4 bytes of data
  * \param   x data to write
  */
-inline void mbedtls_put_unaligned_uint32(void *p, uint32_t x)
+inline void esp_mbedtls_put_unaligned_uint32(void *p, uint32_t x)
 {
     memcpy(p, &x, sizeof(x));
 }
@@ -105,7 +105,7 @@ inline void mbedtls_put_unaligned_uint32(void *p, uint32_t x)
  * \param   p pointer to 8 bytes of data
  * \return  Data at the given address
  */
-inline uint64_t mbedtls_get_unaligned_uint64(const void *p)
+inline uint64_t esp_mbedtls_get_unaligned_uint64(const void *p)
 {
     uint64_t r;
     memcpy(&r, p, sizeof(r));
@@ -119,7 +119,7 @@ inline uint64_t mbedtls_get_unaligned_uint64(const void *p)
  * \param   p pointer to 8 bytes of data
  * \param   x data to write
  */
-inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x)
+inline void esp_mbedtls_put_unaligned_uint64(void *p, uint64_t x)
 {
     memcpy(p, &x, sizeof(x));
 }
@@ -192,17 +192,17 @@ inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x)
  * similar instruction.
  */
 #if !defined(MBEDTLS_BSWAP16)
-static inline uint16_t mbedtls_bswap16(uint16_t x)
+static inline uint16_t esp_mbedtls_bswap16(uint16_t x)
 {
     return
         (x & 0x00ff) << 8 |
         (x & 0xff00) >> 8;
 }
-#define MBEDTLS_BSWAP16 mbedtls_bswap16
+#define MBEDTLS_BSWAP16 esp_mbedtls_bswap16
 #endif /* !defined(MBEDTLS_BSWAP16) */
 
 #if !defined(MBEDTLS_BSWAP32)
-static inline uint32_t mbedtls_bswap32(uint32_t x)
+static inline uint32_t esp_mbedtls_bswap32(uint32_t x)
 {
     return
         (x & 0x000000ff) << 24 |
@@ -210,11 +210,11 @@ static inline uint32_t mbedtls_bswap32(uint32_t x)
         (x & 0x00ff0000) >>  8 |
         (x & 0xff000000) >> 24;
 }
-#define MBEDTLS_BSWAP32 mbedtls_bswap32
+#define MBEDTLS_BSWAP32 esp_mbedtls_bswap32
 #endif /* !defined(MBEDTLS_BSWAP32) */
 
 #if !defined(MBEDTLS_BSWAP64)
-static inline uint64_t mbedtls_bswap64(uint64_t x)
+static inline uint64_t esp_mbedtls_bswap64(uint64_t x)
 {
     return
         (x & 0x00000000000000ffULL) << 56 |
@@ -226,12 +226,12 @@ static inline uint64_t mbedtls_bswap64(uint64_t x)
         (x & 0x00ff000000000000ULL) >> 40 |
         (x & 0xff00000000000000ULL) >> 56;
 }
-#define MBEDTLS_BSWAP64 mbedtls_bswap64
+#define MBEDTLS_BSWAP64 esp_mbedtls_bswap64
 #endif /* !defined(MBEDTLS_BSWAP64) */
 
 #if !defined(__BYTE_ORDER__)
-static const uint16_t mbedtls_byte_order_detector = { 0x100 };
-#define MBEDTLS_IS_BIG_ENDIAN (*((unsigned char *) (&mbedtls_byte_order_detector)) == 0x01)
+static const uint16_t esp_mbedtls_byte_order_detector = { 0x100 };
+#define MBEDTLS_IS_BIG_ENDIAN (*((unsigned char *) (&esp_mbedtls_byte_order_detector)) == 0x01)
 #else
 #define MBEDTLS_IS_BIG_ENDIAN ((__BYTE_ORDER__) == (__ORDER_BIG_ENDIAN__))
 #endif /* !defined(__BYTE_ORDER__) */
@@ -247,8 +247,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT32_BE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? mbedtls_get_unaligned_uint32((data) + (offset))                  \
-        : MBEDTLS_BSWAP32(mbedtls_get_unaligned_uint32((data) + (offset))) \
+        ? esp_mbedtls_get_unaligned_uint32((data) + (offset))                  \
+        : MBEDTLS_BSWAP32(esp_mbedtls_get_unaligned_uint32((data) + (offset))) \
     )
 
 /**
@@ -264,11 +264,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint32((data) + (offset), (uint32_t) (n));     \
+            esp_mbedtls_put_unaligned_uint32((data) + (offset), (uint32_t) (n));     \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint32((data) + (offset), MBEDTLS_BSWAP32((uint32_t) (n))); \
+            esp_mbedtls_put_unaligned_uint32((data) + (offset), MBEDTLS_BSWAP32((uint32_t) (n))); \
         }                                                                        \
     }
 
@@ -283,8 +283,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT32_LE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? MBEDTLS_BSWAP32(mbedtls_get_unaligned_uint32((data) + (offset))) \
-        : mbedtls_get_unaligned_uint32((data) + (offset))                  \
+        ? MBEDTLS_BSWAP32(esp_mbedtls_get_unaligned_uint32((data) + (offset))) \
+        : esp_mbedtls_get_unaligned_uint32((data) + (offset))                  \
     )
 
 
@@ -301,11 +301,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint32((data) + (offset), MBEDTLS_BSWAP32((uint32_t) (n))); \
+            esp_mbedtls_put_unaligned_uint32((data) + (offset), MBEDTLS_BSWAP32((uint32_t) (n))); \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint32((data) + (offset), ((uint32_t) (n)));   \
+            esp_mbedtls_put_unaligned_uint32((data) + (offset), ((uint32_t) (n)));   \
         }                                                                        \
     }
 
@@ -320,8 +320,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT16_LE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? MBEDTLS_BSWAP16(mbedtls_get_unaligned_uint16((data) + (offset))) \
-        : mbedtls_get_unaligned_uint16((data) + (offset))                  \
+        ? MBEDTLS_BSWAP16(esp_mbedtls_get_unaligned_uint16((data) + (offset))) \
+        : esp_mbedtls_get_unaligned_uint16((data) + (offset))                  \
     )
 
 /**
@@ -337,11 +337,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint16((data) + (offset), MBEDTLS_BSWAP16((uint16_t) (n))); \
+            esp_mbedtls_put_unaligned_uint16((data) + (offset), MBEDTLS_BSWAP16((uint16_t) (n))); \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint16((data) + (offset), (uint16_t) (n));     \
+            esp_mbedtls_put_unaligned_uint16((data) + (offset), (uint16_t) (n));     \
         }                                                                        \
     }
 
@@ -356,8 +356,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT16_BE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? mbedtls_get_unaligned_uint16((data) + (offset))                  \
-        : MBEDTLS_BSWAP16(mbedtls_get_unaligned_uint16((data) + (offset))) \
+        ? esp_mbedtls_get_unaligned_uint16((data) + (offset))                  \
+        : MBEDTLS_BSWAP16(esp_mbedtls_get_unaligned_uint16((data) + (offset))) \
     )
 
 /**
@@ -373,11 +373,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint16((data) + (offset), (uint16_t) (n));     \
+            esp_mbedtls_put_unaligned_uint16((data) + (offset), (uint16_t) (n));     \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint16((data) + (offset), MBEDTLS_BSWAP16((uint16_t) (n))); \
+            esp_mbedtls_put_unaligned_uint16((data) + (offset), MBEDTLS_BSWAP16((uint16_t) (n))); \
         }                                                                        \
     }
 
@@ -456,8 +456,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT64_BE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? mbedtls_get_unaligned_uint64((data) + (offset))                  \
-        : MBEDTLS_BSWAP64(mbedtls_get_unaligned_uint64((data) + (offset))) \
+        ? esp_mbedtls_get_unaligned_uint64((data) + (offset))                  \
+        : MBEDTLS_BSWAP64(esp_mbedtls_get_unaligned_uint64((data) + (offset))) \
     )
 
 /**
@@ -473,11 +473,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint64((data) + (offset), (uint64_t) (n));     \
+            esp_mbedtls_put_unaligned_uint64((data) + (offset), (uint64_t) (n));     \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint64((data) + (offset), MBEDTLS_BSWAP64((uint64_t) (n))); \
+            esp_mbedtls_put_unaligned_uint64((data) + (offset), MBEDTLS_BSWAP64((uint64_t) (n))); \
         }                                                                        \
     }
 
@@ -492,8 +492,8 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
  */
 #define MBEDTLS_GET_UINT64_LE(data, offset)                                \
     ((MBEDTLS_IS_BIG_ENDIAN)                                               \
-        ? MBEDTLS_BSWAP64(mbedtls_get_unaligned_uint64((data) + (offset))) \
-        : mbedtls_get_unaligned_uint64((data) + (offset))                  \
+        ? MBEDTLS_BSWAP64(esp_mbedtls_get_unaligned_uint64((data) + (offset))) \
+        : esp_mbedtls_get_unaligned_uint64((data) + (offset))                  \
     )
 
 /**
@@ -509,11 +509,11 @@ static const uint16_t mbedtls_byte_order_detector = { 0x100 };
     {                                                                            \
         if (MBEDTLS_IS_BIG_ENDIAN)                                               \
         {                                                                        \
-            mbedtls_put_unaligned_uint64((data) + (offset), MBEDTLS_BSWAP64((uint64_t) (n))); \
+            esp_mbedtls_put_unaligned_uint64((data) + (offset), MBEDTLS_BSWAP64((uint64_t) (n))); \
         }                                                                        \
         else                                                                     \
         {                                                                        \
-            mbedtls_put_unaligned_uint64((data) + (offset), (uint64_t) (n));     \
+            esp_mbedtls_put_unaligned_uint64((data) + (offset), (uint64_t) (n));     \
         }                                                                        \
     }
 
diff --git a/library/aria.c b/library/aria.c
index d048149301928f9eb3fc6ca0cdebc21639715be2..93d8a0687367c22871833fc608597726efdafe83 100644
--- a/library/aria.c
+++ b/library/aria.c
@@ -558,7 +558,7 @@ int esp_mbedtls_aria_crypt_cbc(mbedtls_aria_context *ctx,
             memcpy(temp, input, MBEDTLS_ARIA_BLOCKSIZE);
             esp_mbedtls_aria_crypt_ecb(ctx, input, output);
 
-            mbedtls_xor(output, output, iv, MBEDTLS_ARIA_BLOCKSIZE);
+            esp_mbedtls_xor(output, output, iv, MBEDTLS_ARIA_BLOCKSIZE);
 
             memcpy(iv, temp, MBEDTLS_ARIA_BLOCKSIZE);
 
@@ -568,7 +568,7 @@ int esp_mbedtls_aria_crypt_cbc(mbedtls_aria_context *ctx,
         }
     } else {
         while (length > 0) {
-            mbedtls_xor(output, input, iv, MBEDTLS_ARIA_BLOCKSIZE);
+            esp_mbedtls_xor(output, input, iv, MBEDTLS_ARIA_BLOCKSIZE);
 
             esp_mbedtls_aria_crypt_ecb(ctx, output, output);
             memcpy(iv, output, MBEDTLS_ARIA_BLOCKSIZE);
diff --git a/library/bignum_core.h b/library/bignum_core.h
index 22c37e01f97adb7d632721bd4f0e5a2203a79232..e9cd07cb87f1dfb70a5a389e25bf37bfcbb9ac7a 100644
--- a/library/bignum_core.h
+++ b/library/bignum_core.h
@@ -556,7 +556,7 @@ int esp_mbedtls_mpi_core_random(mbedtls_mpi_uint *X,
  *                 a call to `esp_mbedtls_mpi_core_exp_mod()`.
  *
  * \note           This will always be at least
- *                 `mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`,
+ *                 `esp_mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`,
  *                 i.e. sufficient for a call to `esp_mbedtls_mpi_core_montmul()`.
  *
  * \param AN_limbs The number of limbs in the input `A` and the modulus `N`
@@ -654,7 +654,7 @@ mbedtls_mpi_uint esp_mbedtls_mpi_core_check_zero_ct(const mbedtls_mpi_uint *A,
  * \return         The number of limbs of working memory required by
  *                 `esp_mbedtls_mpi_core_montmul()` (or other similar function).
  */
-static inline size_t mbedtls_mpi_core_montmul_working_limbs(size_t AN_limbs)
+static inline size_t esp_mbedtls_mpi_core_montmul_working_limbs(size_t AN_limbs)
 {
     return 2 * AN_limbs + 1;
 }
@@ -683,7 +683,7 @@ static inline size_t mbedtls_mpi_core_montmul_working_limbs(size_t AN_limbs)
  *                          `esp_mbedtls_mpi_core_montmul_init()`.
  * \param[in]     rr        The residue for `2^{2*n*biL} mod N`.
  * \param[in,out] T         Temporary storage of size at least
- *                          `mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`
+ *                          `esp_mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`
  *                          limbs.
  *                          Its initial content is unused and
  *                          its final content is indeterminate.
@@ -720,7 +720,7 @@ void esp_mbedtls_mpi_core_to_mont_rep(mbedtls_mpi_uint *X,
  *                          This can be determined by calling
  *                          `esp_mbedtls_mpi_core_montmul_init()`.
  * \param[in,out] T         Temporary storage of size at least
- *                          `mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`
+ *                          `esp_mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`
  *                          limbs.
  *                          Its initial content is unused and
  *                          its final content is indeterminate.
diff --git a/library/bignum_mod_raw.c b/library/bignum_mod_raw.c
index f2bdea9ff8ef06f7f9b22c874834838612902229..12d7a80b21b7240822e61fff6f338c8a41d02771 100644
--- a/library/bignum_mod_raw.c
+++ b/library/bignum_mod_raw.c
@@ -247,7 +247,7 @@ int esp_mbedtls_mpi_mod_raw_to_mont_rep(mbedtls_mpi_uint *X,
                                     const mbedtls_mpi_mod_modulus *N)
 {
     mbedtls_mpi_uint *T;
-    const size_t t_limbs = mbedtls_mpi_core_montmul_working_limbs(N->limbs);
+    const size_t t_limbs = esp_mbedtls_mpi_core_montmul_working_limbs(N->limbs);
 
     if ((T = (mbedtls_mpi_uint *) esp_mbedtls_calloc(t_limbs, ciL)) == NULL) {
         return MBEDTLS_ERR_MPI_ALLOC_FAILED;
@@ -264,7 +264,7 @@ int esp_mbedtls_mpi_mod_raw_to_mont_rep(mbedtls_mpi_uint *X,
 int esp_mbedtls_mpi_mod_raw_from_mont_rep(mbedtls_mpi_uint *X,
                                       const mbedtls_mpi_mod_modulus *N)
 {
-    const size_t t_limbs = mbedtls_mpi_core_montmul_working_limbs(N->limbs);
+    const size_t t_limbs = esp_mbedtls_mpi_core_montmul_working_limbs(N->limbs);
     mbedtls_mpi_uint *T;
 
     if ((T = (mbedtls_mpi_uint *) esp_mbedtls_calloc(t_limbs, ciL)) == NULL) {
diff --git a/library/bignum_mod_raw.h b/library/bignum_mod_raw.h
index b3e38d3f7e1e904eba6b034309b839da38355e02..c3204f56b3701a4ec90bca41081ec8a0231491fc 100644
--- a/library/bignum_mod_raw.h
+++ b/library/bignum_mod_raw.h
@@ -259,7 +259,7 @@ void esp_mbedtls_mpi_mod_raw_mul(mbedtls_mpi_uint *X,
  *                 a call to `esp_mbedtls_mpi_mod_raw_inv_prime()`.
  *
  * \note           This will always be at least
- *                 `mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`,
+ *                 `esp_mbedtls_mpi_core_montmul_working_limbs(AN_limbs)`,
  *                 i.e. sufficient for a call to `esp_mbedtls_mpi_core_montmul()`.
  *
  * \param AN_limbs The number of limbs in the input `A` and the modulus `N`
diff --git a/library/camellia.c b/library/camellia.c
index 4a740bbbfefb429d5a5552f5f50270203521541f..f4720ce033f7a6ba565a58d29d47932f29784f6d 100644
--- a/library/camellia.c
+++ b/library/camellia.c
@@ -547,7 +547,7 @@ int esp_mbedtls_camellia_crypt_cbc(mbedtls_camellia_context *ctx,
             memcpy(temp, input, 16);
             esp_mbedtls_camellia_crypt_ecb(ctx, mode, input, output);
 
-            mbedtls_xor(output, output, iv, 16);
+            esp_mbedtls_xor(output, output, iv, 16);
 
             memcpy(iv, temp, 16);
 
@@ -557,7 +557,7 @@ int esp_mbedtls_camellia_crypt_cbc(mbedtls_camellia_context *ctx,
         }
     } else {
         while (length > 0) {
-            mbedtls_xor(output, input, iv, 16);
+            esp_mbedtls_xor(output, input, iv, 16);
 
             esp_mbedtls_camellia_crypt_ecb(ctx, mode, output, output);
             memcpy(iv, output, 16);
diff --git a/library/ccm.c b/library/ccm.c
index 844a50ce5e951ecc27ab8ca22c8daee128d9ea4a..d517785b27c660b5bffb5c5da226dbfabaf6cc2b 100644
--- a/library/ccm.c
+++ b/library/ccm.c
@@ -126,7 +126,7 @@ static int esp_mbedtls_ccm_crypt(mbedtls_ccm_context *ctx,
         return ret;
     }
 
-    mbedtls_xor(output, input, tmp_buf + offset, use_len);
+    esp_mbedtls_xor(output, input, tmp_buf + offset, use_len);
 
     esp_mbedtls_platform_zeroize(tmp_buf, sizeof(tmp_buf));
     return ret;
@@ -302,7 +302,7 @@ int esp_mbedtls_ccm_update_ad(mbedtls_ccm_context *ctx,
                 use_len = add_len;
             }
 
-            mbedtls_xor(ctx->y + offset, ctx->y + offset, add, use_len);
+            esp_mbedtls_xor(ctx->y + offset, ctx->y + offset, add, use_len);
 
             ctx->processed += use_len;
             add_len -= use_len;
@@ -368,7 +368,7 @@ int esp_mbedtls_ccm_update(mbedtls_ccm_context *ctx,
 
         if (ctx->mode == MBEDTLS_CCM_ENCRYPT || \
             ctx->mode == MBEDTLS_CCM_STAR_ENCRYPT) {
-            mbedtls_xor(ctx->y + offset, ctx->y + offset, input, use_len);
+            esp_mbedtls_xor(ctx->y + offset, ctx->y + offset, input, use_len);
 
             if (use_len + offset == 16 || ctx->processed == ctx->plaintext_len) {
                 if ((ret =
@@ -397,7 +397,7 @@ int esp_mbedtls_ccm_update(mbedtls_ccm_context *ctx,
                 goto exit;
             }
 
-            mbedtls_xor(ctx->y + offset, ctx->y + offset, local_output, use_len);
+            esp_mbedtls_xor(ctx->y + offset, ctx->y + offset, local_output, use_len);
 
             memcpy(output, local_output, use_len);
             esp_mbedtls_platform_zeroize(local_output, 16);
diff --git a/library/chacha20.c b/library/chacha20.c
index e39c6aaab9633bcf5228800891e2791b96842757..26f616ed14e617a0b48a49607a7e633889de4735 100644
--- a/library/chacha20.c
+++ b/library/chacha20.c
@@ -233,7 +233,7 @@ int esp_mbedtls_chacha20_update(mbedtls_chacha20_context *ctx,
         esp_chacha20_block(ctx->state, ctx->keystream8);
         ctx->state[CHACHA20_CTR_INDEX]++;
 
-        mbedtls_xor(output + offset, input + offset, ctx->keystream8, 64U);
+        esp_mbedtls_xor(output + offset, input + offset, ctx->keystream8, 64U);
 
         offset += CHACHA20_BLOCK_SIZE_BYTES;
         size   -= CHACHA20_BLOCK_SIZE_BYTES;
@@ -245,7 +245,7 @@ int esp_mbedtls_chacha20_update(mbedtls_chacha20_context *ctx,
         esp_chacha20_block(ctx->state, ctx->keystream8);
         ctx->state[CHACHA20_CTR_INDEX]++;
 
-        mbedtls_xor(output + offset, input + offset, ctx->keystream8, size);
+        esp_mbedtls_xor(output + offset, input + offset, ctx->keystream8, size);
 
         ctx->keystream_bytes_used = size;
 
diff --git a/library/cmac.c b/library/cmac.c
index d024e6ececf5fc0257214b4e1dfe2e3a595ac1af..7d645937ef3e92e8079598bccfb29411102ac443 100644
--- a/library/cmac.c
+++ b/library/cmac.c
@@ -237,7 +237,7 @@ int esp_mbedtls_cipher_cmac_update(mbedtls_cipher_context_t *ctx,
                input,
                block_size - cmac_ctx->unprocessed_len);
 
-        mbedtls_xor(state, cmac_ctx->unprocessed_block, state, block_size);
+        esp_mbedtls_xor(state, cmac_ctx->unprocessed_block, state, block_size);
 
         if ((ret = esp_mbedtls_cipher_update(ctx, state, block_size, state,
                                          &olen)) != 0) {
@@ -255,7 +255,7 @@ int esp_mbedtls_cipher_cmac_update(mbedtls_cipher_context_t *ctx,
     /* Iterate across the input data in block sized chunks, excluding any
      * final partial or complete block */
     for (j = 1; j < n; j++) {
-        mbedtls_xor(state, input, state, block_size);
+        esp_mbedtls_xor(state, input, state, block_size);
 
         if ((ret = esp_mbedtls_cipher_update(ctx, state, block_size, state,
                                          &olen)) != 0) {
@@ -307,14 +307,14 @@ int esp_mbedtls_cipher_cmac_finish(mbedtls_cipher_context_t *ctx,
     /* Calculate last block */
     if (cmac_ctx->unprocessed_len < block_size) {
         esp_cmac_pad(M_last, block_size, last_block, cmac_ctx->unprocessed_len);
-        mbedtls_xor(M_last, M_last, K2, block_size);
+        esp_mbedtls_xor(M_last, M_last, K2, block_size);
     } else {
         /* Last block is complete block */
-        mbedtls_xor(M_last, last_block, K1, block_size);
+        esp_mbedtls_xor(M_last, last_block, K1, block_size);
     }
 
 
-    mbedtls_xor(state, M_last, state, block_size);
+    esp_mbedtls_xor(state, M_last, state, block_size);
     if ((ret = esp_mbedtls_cipher_update(ctx, state, block_size, state,
                                      &olen)) != 0) {
         goto exit;
diff --git a/library/common.h b/library/common.h
index 1273b57d307a8749fd38dd02ee117769b3ff434a..664dd6ec9f412f5cbf0459b17b34af57778c1e4c 100644
--- a/library/common.h
+++ b/library/common.h
@@ -87,7 +87,7 @@ extern void (*esp_mbedtls_test_hook_test_fail)(const char *test, int line, const
  *              Note that this is only a valid pointer if the size of the
  *              buffer is at least \p n + 1.
  */
-static inline unsigned char *mbedtls_buffer_offset(
+static inline unsigned char *esp_mbedtls_buffer_offset(
     unsigned char *p, size_t n)
 {
     return p == NULL ? NULL : p + n;
@@ -95,7 +95,7 @@ static inline unsigned char *mbedtls_buffer_offset(
 
 /** Return an offset into a read-only buffer.
  *
- * Similar to mbedtls_buffer_offset(), but for const pointers.
+ * Similar to esp_mbedtls_buffer_offset(), but for const pointers.
  *
  * \param p     Pointer to a buffer of at least n bytes.
  *              This may be \p NULL if \p n is zero.
@@ -104,7 +104,7 @@ static inline unsigned char *mbedtls_buffer_offset(
  *              Note that this is only a valid pointer if the size of the
  *              buffer is at least \p n + 1.
  */
-static inline const unsigned char *mbedtls_buffer_offset_const(
+static inline const unsigned char *esp_mbedtls_buffer_offset_const(
     const unsigned char *p, size_t n)
 {
     return p == NULL ? NULL : p + n;
@@ -121,13 +121,13 @@ static inline const unsigned char *mbedtls_buffer_offset_const(
  * \param   b Pointer to input (buffer of at least \p n bytes)
  * \param   n Number of bytes to process.
  */
-inline void mbedtls_xor(unsigned char *r, const unsigned char *a, const unsigned char *b, size_t n)
+inline void esp_mbedtls_xor(unsigned char *r, const unsigned char *a, const unsigned char *b, size_t n)
 {
     size_t i = 0;
 #if defined(MBEDTLS_EFFICIENT_UNALIGNED_ACCESS)
     for (; (i + 4) <= n; i += 4) {
-        uint32_t x = mbedtls_get_unaligned_uint32(a + i) ^ mbedtls_get_unaligned_uint32(b + i);
-        mbedtls_put_unaligned_uint32(r + i, x);
+        uint32_t x = esp_mbedtls_get_unaligned_uint32(a + i) ^ esp_mbedtls_get_unaligned_uint32(b + i);
+        esp_mbedtls_put_unaligned_uint32(r + i, x);
     }
 #endif
     for (; i < n; i++) {
diff --git a/library/constant_time.c b/library/constant_time.c
index b2f796dec3e5976ff8e2727d89f367bd96dbc1ed..dde454d2cfe712dc792c56b510280fd76282b58e 100644
--- a/library/constant_time.c
+++ b/library/constant_time.c
@@ -474,9 +474,9 @@ void esp_mbedtls_ct_memcpy_if_eq(unsigned char *dest,
     const unsigned char mask = (unsigned char) mask32 & 0xff;
 
     for (; (i + 4) <= len; i += 4) {
-        uint32_t a = mbedtls_get_unaligned_uint32(src  + i) &  mask32;
-        uint32_t b = mbedtls_get_unaligned_uint32(dest + i) & ~mask32;
-        mbedtls_put_unaligned_uint32(dest + i, a | b);
+        uint32_t a = esp_mbedtls_get_unaligned_uint32(src  + i) &  mask32;
+        uint32_t b = esp_mbedtls_get_unaligned_uint32(dest + i) & ~mask32;
+        esp_mbedtls_put_unaligned_uint32(dest + i, a | b);
     }
 #else
     const unsigned char mask = (unsigned char) esp_mbedtls_ct_size_mask(equal);
diff --git a/library/ctr_drbg.c b/library/ctr_drbg.c
index e7cbb0c4d7d9459ebaca4de241e3fcdda1c83dbc..b3f0a332f73d58e7919f7d9f9790322a81490666 100644
--- a/library/ctr_drbg.c
+++ b/library/ctr_drbg.c
@@ -177,7 +177,7 @@ static int esp_block_cipher_df(unsigned char *output,
         use_len = buf_len;
 
         while (use_len > 0) {
-            mbedtls_xor(chain, chain, p, MBEDTLS_CTR_DRBG_BLOCKSIZE);
+            esp_mbedtls_xor(chain, chain, p, MBEDTLS_CTR_DRBG_BLOCKSIZE);
             p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
             use_len -= (use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE) ?
                        MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;
diff --git a/library/des.c b/library/des.c
index a090c3f6c2464c4647554a6584572464e4f0da38..d4d8e26083c8d93e4487979c32b9d84b13e8a280 100644
--- a/library/des.c
+++ b/library/des.c
@@ -651,7 +651,7 @@ int esp_mbedtls_des_crypt_cbc(mbedtls_des_context *ctx,
 
     if (mode == MBEDTLS_DES_ENCRYPT) {
         while (length > 0) {
-            mbedtls_xor(output, input, iv, 8);
+            esp_mbedtls_xor(output, input, iv, 8);
 
             ret = esp_mbedtls_des_crypt_ecb(ctx, output, output);
             if (ret != 0) {
@@ -671,7 +671,7 @@ int esp_mbedtls_des_crypt_cbc(mbedtls_des_context *ctx,
                 goto exit;
             }
 
-            mbedtls_xor(output, output, iv, 8);
+            esp_mbedtls_xor(output, output, iv, 8);
 
             memcpy(iv, temp, 8);
 
@@ -749,7 +749,7 @@ int esp_mbedtls_des3_crypt_cbc(mbedtls_des3_context *ctx,
 
     if (mode == MBEDTLS_DES_ENCRYPT) {
         while (length > 0) {
-            mbedtls_xor(output, input, iv, 8);
+            esp_mbedtls_xor(output, input, iv, 8);
 
             ret = esp_mbedtls_des3_crypt_ecb(ctx, output, output);
             if (ret != 0) {
@@ -769,7 +769,7 @@ int esp_mbedtls_des3_crypt_cbc(mbedtls_des3_context *ctx,
                 goto exit;
             }
 
-            mbedtls_xor(output, output, iv, 8);
+            esp_mbedtls_xor(output, output, iv, 8);
 
             memcpy(iv, temp, 8);
 
diff --git a/library/gcm.c b/library/gcm.c
index 5a3e1b23419a5fd529b3eeec87c1020444bcbbb0..b23d3b86d0879a01df6535d60429df7b9c65968b 100644
--- a/library/gcm.c
+++ b/library/gcm.c
@@ -291,7 +291,7 @@ int esp_mbedtls_gcm_starts(mbedtls_gcm_context *ctx,
         while (iv_len > 0) {
             use_len = (iv_len < 16) ? iv_len : 16;
 
-            mbedtls_xor(ctx->y, ctx->y, p, use_len);
+            esp_mbedtls_xor(ctx->y, ctx->y, p, use_len);
 
             esp_gcm_mult(ctx, ctx->y, ctx->y);
 
@@ -299,7 +299,7 @@ int esp_mbedtls_gcm_starts(mbedtls_gcm_context *ctx,
             p += use_len;
         }
 
-        mbedtls_xor(ctx->y, ctx->y, work_buf, 16);
+        esp_mbedtls_xor(ctx->y, ctx->y, work_buf, 16);
 
         esp_gcm_mult(ctx, ctx->y, ctx->y);
     }
@@ -349,7 +349,7 @@ int esp_mbedtls_gcm_update_ad(mbedtls_gcm_context *ctx,
             use_len = add_len;
         }
 
-        mbedtls_xor(ctx->buf + offset, ctx->buf + offset, p, use_len);
+        esp_mbedtls_xor(ctx->buf + offset, ctx->buf + offset, p, use_len);
 
         if (offset + use_len == 16) {
             esp_gcm_mult(ctx, ctx->buf, ctx->buf);
@@ -363,7 +363,7 @@ int esp_mbedtls_gcm_update_ad(mbedtls_gcm_context *ctx,
     ctx->add_len += add_len;
 
     while (add_len >= 16) {
-        mbedtls_xor(ctx->buf, ctx->buf, p, 16);
+        esp_mbedtls_xor(ctx->buf, ctx->buf, p, 16);
 
         esp_gcm_mult(ctx, ctx->buf, ctx->buf);
 
@@ -372,7 +372,7 @@ int esp_mbedtls_gcm_update_ad(mbedtls_gcm_context *ctx,
     }
 
     if (add_len > 0) {
-        mbedtls_xor(ctx->buf, ctx->buf, p, add_len);
+        esp_mbedtls_xor(ctx->buf, ctx->buf, p, add_len);
     }
 
     return 0;
@@ -407,11 +407,11 @@ static int esp_gcm_mask(mbedtls_gcm_context *ctx,
     }
 
     if (ctx->mode == MBEDTLS_GCM_DECRYPT) {
-        mbedtls_xor(ctx->buf + offset, ctx->buf + offset, input, use_len);
+        esp_mbedtls_xor(ctx->buf + offset, ctx->buf + offset, input, use_len);
     }
-    mbedtls_xor(output, ectr + offset, input, use_len);
+    esp_mbedtls_xor(output, ectr + offset, input, use_len);
     if (ctx->mode == MBEDTLS_GCM_ENCRYPT) {
-        mbedtls_xor(ctx->buf + offset, ctx->buf + offset, output, use_len);
+        esp_mbedtls_xor(ctx->buf + offset, ctx->buf + offset, output, use_len);
     }
 
     return 0;
@@ -543,11 +543,11 @@ int esp_mbedtls_gcm_finish(mbedtls_gcm_context *ctx,
         MBEDTLS_PUT_UINT32_BE((orig_len     >> 32), work_buf, 8);
         MBEDTLS_PUT_UINT32_BE((orig_len), work_buf, 12);
 
-        mbedtls_xor(ctx->buf, ctx->buf, work_buf, 16);
+        esp_mbedtls_xor(ctx->buf, ctx->buf, work_buf, 16);
 
         esp_gcm_mult(ctx, ctx->buf, ctx->buf);
 
-        mbedtls_xor(tag, tag, ctx->buf, tag_len);
+        esp_mbedtls_xor(tag, tag, ctx->buf, tag_len);
     }
 
     return 0;
diff --git a/library/md.c b/library/md.c
index 22979f53b240e3c3d8ea3ab15791f99bf1175e7a..5ff0004e30b39ed6ec73e67aab6978c5a9e1ab0d 100644
--- a/library/md.c
+++ b/library/md.c
@@ -850,8 +850,8 @@ int esp_mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx, const unsigned char *k
     memset(ipad, 0x36, ctx->md_info->block_size);
     memset(opad, 0x5C, ctx->md_info->block_size);
 
-    mbedtls_xor(ipad, ipad, key, keylen);
-    mbedtls_xor(opad, opad, key, keylen);
+    esp_mbedtls_xor(ipad, ipad, key, keylen);
+    esp_mbedtls_xor(opad, opad, key, keylen);
 
     if ((ret = esp_mbedtls_md_starts(ctx)) != 0) {
         goto cleanup;
diff --git a/library/pkcs5.c b/library/pkcs5.c
index bf102ffbdadef68a20b031f6bcdb7e0927cc9908..562b3db9e757d1d818d93bd3ef45dd68799ddf79 100644
--- a/library/pkcs5.c
+++ b/library/pkcs5.c
@@ -287,7 +287,7 @@ static int esp_pkcs5_pbkdf2_hmac(mbedtls_md_context_t *ctx,
 
             // U1 xor U2
             //
-            mbedtls_xor(work, work, md1, md_size);
+            esp_mbedtls_xor(work, work, md1, md_size);
         }
 
         use_len = (key_length < md_size) ? key_length : md_size;
@@ -429,7 +429,7 @@ exit:
 
             // U1 xor U2
             //
-            mbedtls_xor(work, work, md1, md_size);
+            esp_mbedtls_xor(work, work, md1, md_size);
         }
 
         use_len = (key_length < md_size) ? key_length : md_size;
diff --git a/library/platform_util.c b/library/platform_util.c
index 32f0b9bd7b7ab8f8f90c147e21d2d411b022089e..9cdc07b3cc991efdedf1b8d737fa5c1e0c1f8c0f 100644
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -203,19 +203,19 @@ void (*esp_mbedtls_test_hook_test_fail)(const char *, int, const char *);
  * Provide external definitions of some inline functions so that the compiler
  * has the option to not inline them
  */
-extern inline void mbedtls_xor(unsigned char *r,
+extern inline void esp_mbedtls_xor(unsigned char *r,
                                const unsigned char *a,
                                const unsigned char *b,
                                size_t n);
 
-extern inline uint16_t mbedtls_get_unaligned_uint16(const void *p);
+extern inline uint16_t esp_mbedtls_get_unaligned_uint16(const void *p);
 
-extern inline void mbedtls_put_unaligned_uint16(void *p, uint16_t x);
+extern inline void esp_mbedtls_put_unaligned_uint16(void *p, uint16_t x);
 
-extern inline uint32_t mbedtls_get_unaligned_uint32(const void *p);
+extern inline uint32_t esp_mbedtls_get_unaligned_uint32(const void *p);
 
-extern inline void mbedtls_put_unaligned_uint32(void *p, uint32_t x);
+extern inline void esp_mbedtls_put_unaligned_uint32(void *p, uint32_t x);
 
-extern inline uint64_t mbedtls_get_unaligned_uint64(const void *p);
+extern inline uint64_t esp_mbedtls_get_unaligned_uint64(const void *p);
 
-extern inline void mbedtls_put_unaligned_uint64(void *p, uint64_t x);
+extern inline void esp_mbedtls_put_unaligned_uint64(void *p, uint64_t x);
diff --git a/library/psa_crypto.c b/library/psa_crypto.c
index 2a5801b82151b24bb67cdc41d3ba5bb735c7490a..21944a000f86773924f2460ca3e5c87f31901c69 100644
--- a/library/psa_crypto.c
+++ b/library/psa_crypto.c
@@ -1011,7 +1011,7 @@ static psa_status_t esp_psa_get_and_lock_transparent_key_slot_with_policy(
         return status;
     }
 
-    if (psa_key_lifetime_is_external((*p_slot)->attr.lifetime)) {
+    if (esp_psa_key_lifetime_is_external((*p_slot)->attr.lifetime)) {
         esp_psa_unlock_key_slot(*p_slot);
         *p_slot = NULL;
         return PSA_ERROR_NOT_SUPPORTED;
@@ -1121,9 +1121,9 @@ psa_status_t esp_psa_destroy_key(mbedtls_svc_key_id_t key)
          * key inside the secure element, and update the driver's
          * persistent data. Start a transaction that will encompass these
          * three actions. */
-        psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_DESTROY_KEY);
+        esp_psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_DESTROY_KEY);
         esp_psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
-        esp_psa_crypto_transaction.key.slot = psa_key_slot_get_slot_number(slot);
+        esp_psa_crypto_transaction.key.slot = esp_psa_key_slot_get_slot_number(slot);
         esp_psa_crypto_transaction.key.id = slot->attr.id;
         status = esp_psa_crypto_save_transaction();
         if (status != PSA_SUCCESS) {
@@ -1140,7 +1140,7 @@ psa_status_t esp_psa_destroy_key(mbedtls_svc_key_id_t key)
         }
 
         status = esp_psa_destroy_se_key(driver,
-                                    psa_key_slot_get_slot_number(slot));
+                                    esp_psa_key_slot_get_slot_number(slot));
         if (overall_status == PSA_SUCCESS) {
             overall_status = status;
         }
@@ -1251,7 +1251,7 @@ psa_status_t esp_psa_get_key_attributes(mbedtls_svc_key_id_t key,
 #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
     if (esp_psa_get_se_driver_entry(slot->attr.lifetime) != NULL) {
         psa_set_key_slot_number(attributes,
-                                psa_key_slot_get_slot_number(slot));
+                                esp_psa_key_slot_get_slot_number(slot));
     }
 #endif /* MBEDTLS_PSA_CRYPTO_SE_C */
 
@@ -1264,7 +1264,7 @@ psa_status_t esp_psa_get_key_attributes(mbedtls_svc_key_id_t key,
              * is not yet implemented.
              * https://github.com/ARMmbed/mbed-crypto/issues/216
              */
-            if (!psa_key_lifetime_is_external(slot->attr.lifetime)) {
+            if (!esp_psa_key_lifetime_is_external(slot->attr.lifetime)) {
                 mbedtls_rsa_context *rsa = NULL;
 
                 status = esp_mbedtls_psa_rsa_load_representation(
@@ -1695,7 +1695,7 @@ static psa_status_t esp_psa_start_key_creation(
         }
 
         if (!PSA_KEY_LIFETIME_IS_VOLATILE(attributes->core.lifetime)) {
-            psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_CREATE_KEY);
+            esp_psa_crypto_prepare_transaction(PSA_CRYPTO_TRANSACTION_CREATE_KEY);
             esp_psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
             esp_psa_crypto_transaction.key.slot = slot_number;
             esp_psa_crypto_transaction.key.id = slot->attr.id;
@@ -1764,7 +1764,7 @@ static psa_status_t esp_psa_finish_key_creation(
         if (driver != NULL) {
             psa_se_key_data_storage_t data;
             psa_key_slot_number_t slot_number =
-                psa_key_slot_get_slot_number(slot);
+                esp_psa_key_slot_get_slot_number(slot);
 
             MBEDTLS_STATIC_ASSERT(sizeof(slot_number) ==
                                   sizeof(data.slot_number),
@@ -1968,7 +1968,7 @@ psa_status_t esp_psa_import_key(const psa_key_attributes_t *attributes,
      * with storage ( MBEDTLS_PSA_CRYPTO_SE_C ) ),we have to allocate a
      * buffer to hold the imported key material. */
     if (slot->key.data == NULL) {
-        if (psa_key_lifetime_is_external(attributes->core.lifetime)) {
+        if (esp_psa_key_lifetime_is_external(attributes->core.lifetime)) {
             status = esp_psa_driver_wrapper_get_key_buffer_size_from_key_data(
                 attributes, data, data_length, &storage_size);
             if (status != PSA_SUCCESS) {
@@ -2122,7 +2122,7 @@ psa_status_t esp_psa_copy_key(mbedtls_svc_key_id_t source_key,
      * - For opaque keys this translates to an invocation of the drivers'
      *   copy_key entry point through the dispatch layer.
      * */
-    if (psa_key_lifetime_is_external(actual_attributes.core.lifetime)) {
+    if (esp_psa_key_lifetime_is_external(actual_attributes.core.lifetime)) {
         status = esp_psa_driver_wrapper_get_key_buffer_size(&actual_attributes,
                                                         &storage_size);
         if (status != PSA_SUCCESS) {
@@ -2274,7 +2274,7 @@ psa_status_t esp_psa_hash_verify(psa_hash_operation_t *operation,
         goto exit;
     }
 
-    if (mbedtls_psa_safer_memcmp(hash, actual_hash, actual_hash_length) != 0) {
+    if (esp_mbedtls_psa_safer_memcmp(hash, actual_hash, actual_hash_length) != 0) {
         status = PSA_ERROR_INVALID_SIGNATURE;
     }
 
@@ -2323,7 +2323,7 @@ psa_status_t esp_psa_hash_compare(psa_algorithm_t alg,
         status = PSA_ERROR_INVALID_SIGNATURE;
         goto exit;
     }
-    if (mbedtls_psa_safer_memcmp(hash, actual_hash, actual_hash_length) != 0) {
+    if (esp_mbedtls_psa_safer_memcmp(hash, actual_hash, actual_hash_length) != 0) {
         status = PSA_ERROR_INVALID_SIGNATURE;
     }
 
@@ -2703,7 +2703,7 @@ psa_status_t esp_psa_mac_verify(mbedtls_svc_key_id_t key,
         status = PSA_ERROR_INVALID_SIGNATURE;
         goto exit;
     }
-    if (mbedtls_psa_safer_memcmp(mac, actual_mac, actual_mac_length) != 0) {
+    if (esp_mbedtls_psa_safer_memcmp(mac, actual_mac, actual_mac_length) != 0) {
         status = PSA_ERROR_INVALID_SIGNATURE;
         goto exit;
     }
@@ -4234,7 +4234,7 @@ psa_status_t esp_psa_cipher_encrypt(mbedtls_svc_key_id_t key,
     status = esp_psa_driver_wrapper_cipher_encrypt(
         &attributes, slot->key.data, slot->key.bytes,
         alg, local_iv, default_iv_length, input, input_length,
-        mbedtls_buffer_offset(output, default_iv_length),
+        esp_mbedtls_buffer_offset(output, default_iv_length),
         output_size - default_iv_length, output_length);
 
 exit:
@@ -5789,7 +5789,7 @@ static psa_status_t esp_psa_generate_derived_key_internal(
         .core = slot->attr
     };
 
-    if (psa_key_lifetime_is_external(attributes.core.lifetime)) {
+    if (esp_psa_key_lifetime_is_external(attributes.core.lifetime)) {
         status = esp_psa_driver_wrapper_get_key_buffer_size(&attributes,
                                                         &storage_size);
         if (status != PSA_SUCCESS) {
@@ -6769,7 +6769,7 @@ static void esp_mbedtls_psa_random_init(mbedtls_psa_random_context_t *rng)
                                MBEDTLS_ENTROPY_SOURCE_STRONG);
 #endif
 
-    mbedtls_psa_drbg_init(MBEDTLS_PSA_RANDOM_STATE);
+    esp_mbedtls_psa_drbg_init(MBEDTLS_PSA_RANDOM_STATE);
 #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
 }
 
@@ -6780,7 +6780,7 @@ static void esp_mbedtls_psa_random_free(mbedtls_psa_random_context_t *rng)
 #if defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)
     memset(rng, 0, sizeof(*rng));
 #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
-    mbedtls_psa_drbg_free(MBEDTLS_PSA_RANDOM_STATE);
+    esp_mbedtls_psa_drbg_free(MBEDTLS_PSA_RANDOM_STATE);
     rng->entropy_free(&rng->entropy);
 #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
 }
@@ -6795,7 +6795,7 @@ static psa_status_t esp_mbedtls_psa_random_seed(mbedtls_psa_random_context_t *rn
     return PSA_SUCCESS;
 #else /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
     const unsigned char drbg_seed[] = "PSA";
-    int ret = mbedtls_psa_drbg_seed(&rng->entropy,
+    int ret = esp_mbedtls_psa_drbg_seed(&rng->entropy,
                                     drbg_seed, sizeof(drbg_seed) - 1);
     return esp_mbedtls_to_psa_error(ret);
 #endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
diff --git a/library/psa_crypto_cipher.c b/library/psa_crypto_cipher.c
index 6f87836c7ccb68e964ef393ba7ea8b626762f7dc..8c0ddcd102275912afcfa7f8dbcf0ac17eb20e14 100644
--- a/library/psa_crypto_cipher.c
+++ b/library/psa_crypto_cipher.c
@@ -519,7 +519,7 @@ psa_status_t esp_mbedtls_psa_cipher_encrypt(
 
     status = esp_mbedtls_psa_cipher_finish(
         &operation,
-        mbedtls_buffer_offset(output, update_output_length),
+        esp_mbedtls_buffer_offset(output, update_output_length),
         output_size - update_output_length, &finish_output_length);
     if (status != PSA_SUCCESS) {
         goto exit;
@@ -569,7 +569,7 @@ psa_status_t esp_mbedtls_psa_cipher_decrypt(
 
     status = esp_mbedtls_psa_cipher_update(
         &operation,
-        mbedtls_buffer_offset_const(input, operation.iv_length),
+        esp_mbedtls_buffer_offset_const(input, operation.iv_length),
         input_length - operation.iv_length,
         output, output_size, &olength);
     if (status != PSA_SUCCESS) {
@@ -580,7 +580,7 @@ psa_status_t esp_mbedtls_psa_cipher_decrypt(
 
     status = esp_mbedtls_psa_cipher_finish(
         &operation,
-        mbedtls_buffer_offset(output, accumulated_length),
+        esp_mbedtls_buffer_offset(output, accumulated_length),
         output_size - accumulated_length, &olength);
     if (status != PSA_SUCCESS) {
         goto exit;
diff --git a/library/psa_crypto_core.h b/library/psa_crypto_core.h
index e7612cba496724c32e9fd4943511b0dea9d22590..f2c0a0eeb6ed4ebd619cdf9f3bf64c65c2156ea0 100644
--- a/library/psa_crypto_core.h
+++ b/library/psa_crypto_core.h
@@ -46,7 +46,7 @@ int esp_psa_can_do_hash(psa_algorithm_t hash_alg);
  *
  * \return 0 if the buffer contents are equal, non-zero otherwise
  */
-static inline int mbedtls_psa_safer_memcmp(
+static inline int esp_mbedtls_psa_safer_memcmp(
     const uint8_t *a, const uint8_t *b, size_t n)
 {
     size_t i;
@@ -112,7 +112,7 @@ typedef struct {
  *
  * \return 1 if the slot is occupied, 0 otherwise.
  */
-static inline int psa_is_key_slot_occupied(const psa_key_slot_t *slot)
+static inline int esp_psa_is_key_slot_occupied(const psa_key_slot_t *slot)
 {
     return slot->attr.type != 0;
 }
@@ -125,7 +125,7 @@ static inline int psa_is_key_slot_occupied(const psa_key_slot_t *slot)
  *
  * \return 1 if the slot is locked, 0 otherwise.
  */
-static inline int psa_is_key_slot_locked(const psa_key_slot_t *slot)
+static inline int esp_psa_is_key_slot_locked(const psa_key_slot_t *slot)
 {
     return slot->lock_count > 0;
 }
@@ -138,7 +138,7 @@ static inline int psa_is_key_slot_locked(const psa_key_slot_t *slot)
  * \return The key attribute flags in the given slot,
  *         bitwise-anded with \p mask.
  */
-static inline uint16_t psa_key_slot_get_flags(const psa_key_slot_t *slot,
+static inline uint16_t esp_psa_key_slot_get_flags(const psa_key_slot_t *slot,
                                               uint16_t mask)
 {
     return slot->attr.flags & mask;
@@ -150,7 +150,7 @@ static inline uint16_t psa_key_slot_get_flags(const psa_key_slot_t *slot,
  * \param mask          The mask of bits to modify.
  * \param value         The new value of the selected bits.
  */
-static inline void psa_key_slot_set_flags(psa_key_slot_t *slot,
+static inline void esp_psa_key_slot_set_flags(psa_key_slot_t *slot,
                                           uint16_t mask,
                                           uint16_t value)
 {
@@ -163,7 +163,7 @@ static inline void psa_key_slot_set_flags(psa_key_slot_t *slot,
  * \param[in,out] slot  The key slot to modify.
  * \param mask          The mask of bits to set.
  */
-static inline void psa_key_slot_set_bits_in_flags(psa_key_slot_t *slot,
+static inline void esp_psa_key_slot_set_bits_in_flags(psa_key_slot_t *slot,
                                                   uint16_t mask)
 {
     slot->attr.flags |= mask;
@@ -174,7 +174,7 @@ static inline void psa_key_slot_set_bits_in_flags(psa_key_slot_t *slot,
  * \param[in,out] slot  The key slot to modify.
  * \param mask          The mask of bits to clear.
  */
-static inline void psa_key_slot_clear_bits(psa_key_slot_t *slot,
+static inline void esp_psa_key_slot_clear_bits(psa_key_slot_t *slot,
                                            uint16_t mask)
 {
     slot->attr.flags &= ~mask;
@@ -187,7 +187,7 @@ static inline void psa_key_slot_clear_bits(psa_key_slot_t *slot,
  *                   the description of a key of a dynamically registered
  *                   secure element, otherwise the behaviour is undefined.
  */
-static inline psa_key_slot_number_t psa_key_slot_get_slot_number(
+static inline psa_key_slot_number_t esp_psa_key_slot_get_slot_number(
     const psa_key_slot_t *slot)
 {
     return *((psa_key_slot_number_t *) (slot->key.data));
diff --git a/library/psa_crypto_driver_wrappers.c b/library/psa_crypto_driver_wrappers.c
index 64047d4597d9191489320d566501f500d4b10050..17741233b7ad8513554e31987978bd9b3cf86671 100644
--- a/library/psa_crypto_driver_wrappers.c
+++ b/library/psa_crypto_driver_wrappers.c
@@ -2237,7 +2237,7 @@ psa_status_t esp_psa_driver_wrapper_aead_verify(
                 if( status == PSA_SUCCESS )
                 {
                     if( tag_length != check_tag_length ||
-                        mbedtls_psa_safer_memcmp( tag, check_tag, tag_length )
+                        esp_mbedtls_psa_safer_memcmp( tag, check_tag, tag_length )
                         != 0 )
                         status = PSA_ERROR_INVALID_SIGNATURE;
                 }
diff --git a/library/psa_crypto_mac.c b/library/psa_crypto_mac.c
index 7d555b81e13e8dc1ae3369e4c70717d2739732cb..450173742daf18777c21df14edc60c51841e8674 100644
--- a/library/psa_crypto_mac.c
+++ b/library/psa_crypto_mac.c
@@ -453,7 +453,7 @@ psa_status_t esp_mbedtls_psa_mac_verify_finish(
         goto cleanup;
     }
 
-    if (mbedtls_psa_safer_memcmp(mac, actual_mac, mac_length) != 0) {
+    if (esp_mbedtls_psa_safer_memcmp(mac, actual_mac, mac_length) != 0) {
         status = PSA_ERROR_INVALID_SIGNATURE;
     }
 
diff --git a/library/psa_crypto_random_impl.h b/library/psa_crypto_random_impl.h
index 3779de24a9c0deef18dd76a466f6f4a6af3494cc..9e7405db620191127f458fd757212199d42908d1 100644
--- a/library/psa_crypto_random_impl.h
+++ b/library/psa_crypto_random_impl.h
@@ -89,7 +89,7 @@ int esp_mbedtls_psa_get_random(void *p_rng,
  *
  * \param p_rng        Pointer to the Mbed TLS DRBG state.
  */
-static inline void mbedtls_psa_drbg_init(mbedtls_psa_drbg_context_t *p_rng)
+static inline void esp_mbedtls_psa_drbg_init(mbedtls_psa_drbg_context_t *p_rng)
 {
 #if defined(MBEDTLS_CTR_DRBG_C)
     esp_mbedtls_ctr_drbg_init(p_rng);
@@ -102,7 +102,7 @@ static inline void mbedtls_psa_drbg_init(mbedtls_psa_drbg_context_t *p_rng)
  *
  * \param p_rng        Pointer to the Mbed TLS DRBG state.
  */
-static inline void mbedtls_psa_drbg_free(mbedtls_psa_drbg_context_t *p_rng)
+static inline void esp_mbedtls_psa_drbg_free(mbedtls_psa_drbg_context_t *p_rng)
 {
 #if defined(MBEDTLS_CTR_DRBG_C)
     esp_mbedtls_ctr_drbg_free(p_rng);
@@ -179,7 +179,7 @@ extern mbedtls_psa_drbg_context_t *const esp_mbedtls_psa_random_state;
  * \return              \c 0 on success.
  * \return              An Mbed TLS error code (\c MBEDTLS_ERR_xxx) on failure.
  */
-static inline int mbedtls_psa_drbg_seed(
+static inline int esp_mbedtls_psa_drbg_seed(
     mbedtls_entropy_context *entropy,
     const unsigned char *custom, size_t len)
 {
diff --git a/library/psa_crypto_slot_management.c b/library/psa_crypto_slot_management.c
index 8f6e0b53f3c688de937f39322848eb380dfa0995..d2d9cc36609656c96aca48e871c43610ab95fa03 100644
--- a/library/psa_crypto_slot_management.c
+++ b/library/psa_crypto_slot_management.c
@@ -102,7 +102,7 @@ static psa_status_t esp_psa_get_and_lock_key_slot_in_memory(
     size_t slot_idx;
     psa_key_slot_t *slot = NULL;
 
-    if (psa_key_id_is_volatile(key_id)) {
+    if (esp_psa_key_id_is_volatile(key_id)) {
         slot = &esp_global_data.key_slots[key_id - PSA_KEY_ID_VOLATILE_MIN];
 
         /*
@@ -131,7 +131,7 @@ static psa_status_t esp_psa_get_and_lock_key_slot_in_memory(
     }
 
     if (status == PSA_SUCCESS) {
-        status = psa_lock_key_slot(slot);
+        status = esp_psa_lock_key_slot(slot);
         if (status == PSA_SUCCESS) {
             *p_slot = slot;
         }
@@ -176,14 +176,14 @@ psa_status_t esp_psa_get_empty_key_slot(psa_key_id_t *volatile_key_id,
     selected_slot = unlocked_persistent_key_slot = NULL;
     for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
         psa_key_slot_t *slot = &esp_global_data.key_slots[slot_idx];
-        if (!psa_is_key_slot_occupied(slot)) {
+        if (!esp_psa_is_key_slot_occupied(slot)) {
             selected_slot = slot;
             break;
         }
 
         if ((unlocked_persistent_key_slot == NULL) &&
             (!PSA_KEY_LIFETIME_IS_VOLATILE(slot->attr.lifetime)) &&
-            (!psa_is_key_slot_locked(slot))) {
+            (!esp_psa_is_key_slot_locked(slot))) {
             unlocked_persistent_key_slot = slot;
         }
     }
@@ -203,7 +203,7 @@ psa_status_t esp_psa_get_empty_key_slot(psa_key_id_t *volatile_key_id,
     }
 
     if (selected_slot != NULL) {
-        status = psa_lock_key_slot(selected_slot);
+        status = esp_psa_lock_key_slot(selected_slot);
         if (status != PSA_SUCCESS) {
             goto error;
         }
@@ -424,7 +424,7 @@ psa_status_t esp_psa_unlock_key_slot(psa_key_slot_t *slot)
 psa_status_t esp_psa_validate_key_location(psa_key_lifetime_t lifetime,
                                        psa_se_drv_table_entry_t **p_drv)
 {
-    if (psa_key_lifetime_is_external(lifetime)) {
+    if (esp_psa_key_lifetime_is_external(lifetime)) {
 #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
         /* Check whether a driver is registered against this lifetime */
         psa_se_drv_table_entry_t *driver = esp_psa_get_se_driver_entry(lifetime);
@@ -549,10 +549,10 @@ void esp_mbedtls_psa_get_stats(mbedtls_psa_stats_t *stats)
 
     for (slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++) {
         const psa_key_slot_t *slot = &esp_global_data.key_slots[slot_idx];
-        if (psa_is_key_slot_locked(slot)) {
+        if (esp_psa_is_key_slot_locked(slot)) {
             ++stats->locked_slots;
         }
-        if (!psa_is_key_slot_occupied(slot)) {
+        if (!esp_psa_is_key_slot_occupied(slot)) {
             ++stats->empty_slots;
             continue;
         }
diff --git a/library/psa_crypto_slot_management.h b/library/psa_crypto_slot_management.h
index e800aaac7e8e0e91591f20aec3b38a50634c72db..43275ef9ca9783168e6e998c24478e0f185195bf 100644
--- a/library/psa_crypto_slot_management.h
+++ b/library/psa_crypto_slot_management.h
@@ -51,7 +51,7 @@
  * \retval 0
  *         The key identifier is not a volatile key identifier.
  */
-static inline int psa_key_id_is_volatile(psa_key_id_t key_id)
+static inline int esp_psa_key_id_is_volatile(psa_key_id_t key_id)
 {
     return (key_id >= PSA_KEY_ID_VOLATILE_MIN) &&
            (key_id <= PSA_KEY_ID_VOLATILE_MAX);
@@ -137,7 +137,7 @@ psa_status_t esp_psa_get_empty_key_slot(psa_key_id_t *volatile_key_id,
  *             The lock counter already reached its maximum value and was not
  *             increased.
  */
-static inline psa_status_t psa_lock_key_slot(psa_key_slot_t *slot)
+static inline psa_status_t esp_psa_lock_key_slot(psa_key_slot_t *slot)
 {
     if (slot->lock_count >= SIZE_MAX) {
         return PSA_ERROR_CORRUPTION_DETECTED;
@@ -178,7 +178,7 @@ psa_status_t esp_psa_unlock_key_slot(psa_key_slot_t *slot);
  *         The lifetime designates a key that is volatile or in internal
  *         storage.
  */
-static inline int psa_key_lifetime_is_external(psa_key_lifetime_t lifetime)
+static inline int esp_psa_key_lifetime_is_external(psa_key_lifetime_t lifetime)
 {
     return PSA_KEY_LIFETIME_GET_LOCATION(lifetime)
            != PSA_KEY_LOCATION_LOCAL_STORAGE;
diff --git a/library/psa_crypto_storage.h b/library/psa_crypto_storage.h
index bbd4d368893421e3f7fa99256756b16ea57c6867..328307630fd41b512146748c7ea0371533680d6b 100644
--- a/library/psa_crypto_storage.h
+++ b/library/psa_crypto_storage.h
@@ -252,7 +252,7 @@ typedef uint16_t psa_crypto_transaction_type_t;
  * The lifetime of a transaction is the following (note that only one
  * transaction may be active at a time):
  *
- * -# Call psa_crypto_prepare_transaction() to initialize the transaction
+ * -# Call esp_psa_crypto_prepare_transaction() to initialize the transaction
  *    object in memory and declare the type of transaction that is starting.
  * -# Fill in the type-specific fields of #esp_psa_crypto_transaction.
  * -# Call esp_psa_crypto_save_transaction() to start the transaction. This
@@ -311,7 +311,7 @@ extern psa_crypto_transaction_t esp_psa_crypto_transaction;
  *
  * \param type          The type of transaction to start.
  */
-static inline void psa_crypto_prepare_transaction(
+static inline void esp_psa_crypto_prepare_transaction(
     psa_crypto_transaction_type_t type)
 {
     esp_psa_crypto_transaction.unknown.type = type;
diff --git a/library/ssl_client.c b/library/ssl_client.c
index a0e9a46ee92679c43c42a0eaaf3dedb1a6e084f9..2418f766e7d771d3cf588b76280ea970caf831f2 100644
--- a/library/ssl_client.c
+++ b/library/ssl_client.c
@@ -104,7 +104,7 @@ static int esp_ssl_write_hostname_ext(mbedtls_ssl_context *ssl,
     *olen = hostname_len + 9;
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SERVERNAME);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SERVERNAME);
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
     return 0;
 }
@@ -178,7 +178,7 @@ static int esp_ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
     MBEDTLS_PUT_UINT16_BE(*out_len - 4, buf, 2);
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
     return 0;
 }
@@ -234,7 +234,7 @@ static int esp_ssl_write_supported_groups_ext(mbedtls_ssl_context *ssl,
     unsigned char *p = buf;
     unsigned char *named_group_list; /* Start of named_group_list */
     size_t named_group_list_len;     /* Length of named_group_list */
-    const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+    const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
 
     *out_len = 0;
 
@@ -258,10 +258,10 @@ static int esp_ssl_write_supported_groups_ext(mbedtls_ssl_context *ssl,
         MBEDTLS_SSL_DEBUG_MSG(1, ("got supported group(%04x)", *group_list));
 
 #if defined(MBEDTLS_ECP_C)
-        if ((mbedtls_ssl_conf_is_tls13_enabled(ssl->conf) &&
-             mbedtls_ssl_tls13_named_group_is_ecdhe(*group_list)) ||
-            (mbedtls_ssl_conf_is_tls12_enabled(ssl->conf) &&
-             mbedtls_ssl_tls12_named_group_is_ecdhe(*group_list))) {
+        if ((esp_mbedtls_ssl_conf_is_tls13_enabled(ssl->conf) &&
+             esp_mbedtls_ssl_tls13_named_group_is_ecdhe(*group_list)) ||
+            (esp_mbedtls_ssl_conf_is_tls12_enabled(ssl->conf) &&
+             esp_mbedtls_ssl_tls12_named_group_is_ecdhe(*group_list))) {
             if (esp_mbedtls_ssl_get_ecp_group_id_from_tls_id(*group_list) ==
                 MBEDTLS_ECP_DP_NONE) {
                 continue;
@@ -298,7 +298,7 @@ static int esp_ssl_write_supported_groups_ext(mbedtls_ssl_context *ssl,
     *out_len = p - buf;
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
         ssl, MBEDTLS_TLS_EXT_SUPPORTED_GROUPS);
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
 
@@ -602,7 +602,7 @@ static int esp_ssl_write_client_hello_body(mbedtls_ssl_context *ssl,
     if (
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
         (propose_tls13 &&
-         mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) ||
+         esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) ||
 #endif
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
         (propose_tls12 && tls12_uses_ec) ||
@@ -619,7 +619,7 @@ static int esp_ssl_write_client_hello_body(mbedtls_ssl_context *ssl,
 #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
     if (
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-        (propose_tls13 && mbedtls_ssl_conf_tls13_ephemeral_enabled(ssl)) ||
+        (propose_tls13 && esp_mbedtls_ssl_conf_tls13_ephemeral_enabled(ssl)) ||
 #endif
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
         propose_tls12 ||
@@ -649,7 +649,7 @@ static int esp_ssl_write_client_hello_body(mbedtls_ssl_context *ssl,
     /* The "pre_shared_key" extension (RFC 8446 Section 4.2.11)
      * MUST be the last extension in the ClientHello.
      */
-    if (propose_tls13 && mbedtls_ssl_conf_tls13_some_psk_enabled(ssl)) {
+    if (propose_tls13 && esp_mbedtls_ssl_conf_tls13_some_psk_enabled(ssl)) {
         ret = esp_mbedtls_ssl_tls13_write_identities_of_pre_shared_key_ext(
             ssl, p, end, &output_len, binders_len);
         if (ret != 0) {
@@ -930,10 +930,10 @@ int esp_mbedtls_ssl_write_client_hello(mbedtls_ssl_context *ssl)
          * that we will not write and send again a ClientHello when we
          * eventually succeed in sending the pending data.
          */
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
 
-        if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-            MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+        if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+            MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
             return ret;
         }
 
@@ -979,7 +979,7 @@ int esp_mbedtls_ssl_write_client_hello(mbedtls_ssl_context *ssl)
          * Set next state. Note that if TLS 1.3 is proposed, this may be
          * overwritten by esp_mbedtls_ssl_tls13_finalize_client_hello().
          */
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
         if (ssl->handshake->min_tls_version <=  MBEDTLS_SSL_VERSION_TLS1_3 &&
diff --git a/library/ssl_misc.h b/library/ssl_misc.h
index 250dbdfcee208752bca9bc71e0291b30c4827afa..c5b66e901e998e2b1c8a7b9a7a9ef12371172b57 100644
--- a/library/ssl_misc.h
+++ b/library/ssl_misc.h
@@ -452,7 +452,7 @@ size_t esp_mbedtls_ssl_get_input_max_frag_len(const mbedtls_ssl_context *ssl);
 #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
 
 #if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)
-static inline size_t mbedtls_ssl_get_output_buflen(const mbedtls_ssl_context *ctx)
+static inline size_t esp_mbedtls_ssl_get_output_buflen(const mbedtls_ssl_context *ctx)
 {
 #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
     return esp_mbedtls_ssl_get_output_max_frag_len(ctx)
@@ -464,7 +464,7 @@ static inline size_t mbedtls_ssl_get_output_buflen(const mbedtls_ssl_context *ct
 #endif
 }
 
-static inline size_t mbedtls_ssl_get_input_buflen(const mbedtls_ssl_context *ctx)
+static inline size_t esp_mbedtls_ssl_get_input_buflen(const mbedtls_ssl_context *ctx)
 {
 #if defined(MBEDTLS_SSL_DTLS_CONNECTION_ID)
     return esp_mbedtls_ssl_get_input_max_frag_len(ctx)
@@ -497,7 +497,7 @@ static inline size_t mbedtls_ssl_get_input_buflen(const mbedtls_ssl_context *ctx
  *               otherwise.
  */
 #if !defined(MBEDTLS_TEST_HOOKS)
-static inline int mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
+static inline int esp_mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
                                           const uint8_t *end, size_t need)
 {
     return (cur > end) || (need > (size_t) (end - cur));
@@ -516,7 +516,7 @@ void esp_mbedtls_ssl_reset_chk_buf_ptr_fail_args(void);
 MBEDTLS_CHECK_RETURN_CRITICAL
 int esp_mbedtls_ssl_cmp_chk_buf_ptr_fail_args(mbedtls_ssl_chk_buf_ptr_args *args);
 
-static inline int mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
+static inline int esp_mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
                                           const uint8_t *end, size_t need)
 {
     if ((cur > end) || (need > (size_t) (end - cur))) {
@@ -539,7 +539,7 @@ static inline int mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
  */
 #define MBEDTLS_SSL_CHK_BUF_PTR(cur, end, need)                        \
     do {                                                                 \
-        if (mbedtls_ssl_chk_buf_ptr((cur), (end), (need)) != 0) \
+        if (esp_mbedtls_ssl_chk_buf_ptr((cur), (end), (need)) != 0) \
         {                                                                \
             return MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL;                  \
         }                                                                \
@@ -561,7 +561,7 @@ static inline int mbedtls_ssl_chk_buf_ptr(const uint8_t *cur,
  */
 #define MBEDTLS_SSL_CHK_BUF_READ_PTR(cur, end, need)                          \
     do {                                                                        \
-        if (mbedtls_ssl_chk_buf_ptr((cur), (end), (need)) != 0)        \
+        if (esp_mbedtls_ssl_chk_buf_ptr((cur), (end), (need)) != 0)        \
         {                                                                       \
             MBEDTLS_SSL_DEBUG_MSG(1,                                           \
                                   ("missing input data in %s", __func__));  \
@@ -1159,7 +1159,7 @@ struct mbedtls_ssl_transform {
  * Return 1 if the transform uses an AEAD cipher, 0 otherwise.
  * Equivalently, return 0 if a separate MAC is used, 1 otherwise.
  */
-static inline int mbedtls_ssl_transform_uses_aead(
+static inline int esp_mbedtls_ssl_transform_uses_aead(
     const mbedtls_ssl_transform *transform)
 {
 #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
@@ -1315,7 +1315,7 @@ int esp_mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl);
 MBEDTLS_CHECK_RETURN_CRITICAL
 int esp_mbedtls_ssl_handshake_server_step(mbedtls_ssl_context *ssl);
 void esp_mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl);
-static inline void mbedtls_ssl_handshake_set_state(mbedtls_ssl_context *ssl,
+static inline void esp_mbedtls_ssl_handshake_set_state(mbedtls_ssl_context *ssl,
                                                    mbedtls_ssl_states state)
 {
     ssl->state = (int) state;
@@ -1432,7 +1432,7 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 int esp_mbedtls_ssl_write_handshake_msg_ext(mbedtls_ssl_context *ssl,
                                         int update_checksum,
                                         int force_flush);
-static inline int mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_write_handshake_msg(mbedtls_ssl_context *ssl)
 {
     return esp_mbedtls_ssl_write_handshake_msg_ext(ssl, 1 /* update checksum */, 1 /* force flush */);
 }
@@ -1502,7 +1502,7 @@ int esp_mbedtls_ssl_conf_has_static_psk(mbedtls_ssl_config const *conf);
  * 2. static PSK configured by \c esp_mbedtls_ssl_conf_psk_opaque()
  * Return an opaque PSK
  */
-static inline mbedtls_svc_key_id_t mbedtls_ssl_get_opaque_psk(
+static inline mbedtls_svc_key_id_t esp_mbedtls_ssl_get_opaque_psk(
     const mbedtls_ssl_context *ssl)
 {
     if (!mbedtls_svc_key_id_is_null(ssl->handshake->psk_opaque)) {
@@ -1522,7 +1522,7 @@ static inline mbedtls_svc_key_id_t mbedtls_ssl_get_opaque_psk(
  * 2. static PSK configured by \c esp_mbedtls_ssl_conf_psk()
  * Return a code and update the pair (PSK, PSK length) passed to this function
  */
-static inline int mbedtls_ssl_get_psk(const mbedtls_ssl_context *ssl,
+static inline int esp_mbedtls_ssl_get_psk(const mbedtls_ssl_context *ssl,
                                       const unsigned char **psk, size_t *psk_len)
 {
     if (ssl->handshake->psk != NULL && ssl->handshake->psk_len > 0) {
@@ -1614,7 +1614,7 @@ const char *esp_mbedtls_ssl_get_curve_name_from_tls_id(uint16_t tls_id);
 #endif
 
 #if defined(MBEDTLS_SSL_DTLS_SRTP)
-static inline mbedtls_ssl_srtp_profile mbedtls_ssl_check_srtp_profile_value
+static inline mbedtls_ssl_srtp_profile esp_mbedtls_ssl_check_srtp_profile_value
     (const uint16_t srtp_profile_value)
 {
     switch (srtp_profile_value) {
@@ -1630,7 +1630,7 @@ static inline mbedtls_ssl_srtp_profile mbedtls_ssl_check_srtp_profile_value
 #endif
 
 #if defined(MBEDTLS_X509_CRT_PARSE_C)
-static inline mbedtls_pk_context *mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)
+static inline mbedtls_pk_context *esp_mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)
 {
     mbedtls_ssl_key_cert *key_cert;
 
@@ -1643,7 +1643,7 @@ static inline mbedtls_pk_context *mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)
     return key_cert == NULL ? NULL : key_cert->key;
 }
 
-static inline mbedtls_x509_crt *mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl)
+static inline mbedtls_x509_crt *esp_mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl)
 {
     mbedtls_ssl_key_cert *key_cert;
 
@@ -1677,7 +1677,7 @@ void esp_mbedtls_ssl_write_version(unsigned char version[2], int transport,
 uint16_t esp_mbedtls_ssl_read_version(const unsigned char version[2],
                                   int transport);
 
-static inline size_t mbedtls_ssl_in_hdr_len(const mbedtls_ssl_context *ssl)
+static inline size_t esp_mbedtls_ssl_in_hdr_len(const mbedtls_ssl_context *ssl)
 {
 #if !defined(MBEDTLS_SSL_PROTO_DTLS)
     ((void) ssl);
@@ -1693,12 +1693,12 @@ static inline size_t mbedtls_ssl_in_hdr_len(const mbedtls_ssl_context *ssl)
     }
 }
 
-static inline size_t mbedtls_ssl_out_hdr_len(const mbedtls_ssl_context *ssl)
+static inline size_t esp_mbedtls_ssl_out_hdr_len(const mbedtls_ssl_context *ssl)
 {
     return (size_t) (ssl->out_iv - ssl->out_hdr);
 }
 
-static inline size_t mbedtls_ssl_hs_hdr_len(const mbedtls_ssl_context *ssl)
+static inline size_t esp_mbedtls_ssl_hs_hdr_len(const mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
@@ -1756,7 +1756,7 @@ int esp_mbedtls_ssl_decrypt_buf(mbedtls_ssl_context const *ssl,
                             mbedtls_record *rec);
 
 /* Length of the "epoch" field in the record header */
-static inline size_t mbedtls_ssl_ep_len(const mbedtls_ssl_context *ssl)
+static inline size_t esp_mbedtls_ssl_ep_len(const mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
     if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
@@ -1826,7 +1826,7 @@ void esp_mbedtls_ssl_flight_free(mbedtls_ssl_flight_item *flight);
  */
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-static inline int mbedtls_ssl_conf_is_tls13_only(const mbedtls_ssl_config *conf)
+static inline int esp_mbedtls_ssl_conf_is_tls13_only(const mbedtls_ssl_config *conf)
 {
     return conf->min_tls_version == MBEDTLS_SSL_VERSION_TLS1_3 &&
            conf->max_tls_version == MBEDTLS_SSL_VERSION_TLS1_3;
@@ -1835,7 +1835,7 @@ static inline int mbedtls_ssl_conf_is_tls13_only(const mbedtls_ssl_config *conf)
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-static inline int mbedtls_ssl_conf_is_tls12_only(const mbedtls_ssl_config *conf)
+static inline int esp_mbedtls_ssl_conf_is_tls12_only(const mbedtls_ssl_config *conf)
 {
     return conf->min_tls_version == MBEDTLS_SSL_VERSION_TLS1_2 &&
            conf->max_tls_version == MBEDTLS_SSL_VERSION_TLS1_2;
@@ -1843,7 +1843,7 @@ static inline int mbedtls_ssl_conf_is_tls12_only(const mbedtls_ssl_config *conf)
 
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
 
-static inline int mbedtls_ssl_conf_is_tls13_enabled(const mbedtls_ssl_config *conf)
+static inline int esp_mbedtls_ssl_conf_is_tls13_enabled(const mbedtls_ssl_config *conf)
 {
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
     return conf->min_tls_version <= MBEDTLS_SSL_VERSION_TLS1_3 &&
@@ -1854,7 +1854,7 @@ static inline int mbedtls_ssl_conf_is_tls13_enabled(const mbedtls_ssl_config *co
 #endif
 }
 
-static inline int mbedtls_ssl_conf_is_tls12_enabled(const mbedtls_ssl_config *conf)
+static inline int esp_mbedtls_ssl_conf_is_tls12_enabled(const mbedtls_ssl_config *conf)
 {
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
     return conf->min_tls_version <= MBEDTLS_SSL_VERSION_TLS1_2 &&
@@ -1866,7 +1866,7 @@ static inline int mbedtls_ssl_conf_is_tls12_enabled(const mbedtls_ssl_config *co
 }
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
-static inline int mbedtls_ssl_conf_is_hybrid_tls12_tls13(const mbedtls_ssl_config *conf)
+static inline int esp_mbedtls_ssl_conf_is_hybrid_tls12_tls13(const mbedtls_ssl_config *conf)
 {
     return conf->min_tls_version == MBEDTLS_SSL_VERSION_TLS1_2 &&
            conf->max_tls_version == MBEDTLS_SSL_VERSION_TLS1_3;
@@ -1917,39 +1917,39 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl);
 /*
  * Helper functions around key exchange modes.
  */
-static inline unsigned mbedtls_ssl_conf_tls13_check_kex_modes(mbedtls_ssl_context *ssl,
+static inline unsigned esp_mbedtls_ssl_conf_tls13_check_kex_modes(mbedtls_ssl_context *ssl,
                                                               int kex_mode_mask)
 {
     return (ssl->conf->tls13_kex_modes & kex_mode_mask) != 0;
 }
 
-static inline int mbedtls_ssl_conf_tls13_psk_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_conf_tls13_psk_enabled(mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
+    return esp_mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
                                                   MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK);
 }
 
-static inline int mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
+    return esp_mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
                                                   MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL);
 }
 
-static inline int mbedtls_ssl_conf_tls13_ephemeral_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_conf_tls13_ephemeral_enabled(mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
+    return esp_mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
                                                   MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL);
 }
 
-static inline int mbedtls_ssl_conf_tls13_some_ephemeral_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
+    return esp_mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
                                                   MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL);
 }
 
-static inline int mbedtls_ssl_conf_tls13_some_psk_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_conf_tls13_some_psk_enabled(mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
+    return esp_mbedtls_ssl_conf_tls13_check_kex_modes(ssl,
                                                   MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL);
 }
 
@@ -1965,40 +1965,40 @@ static inline int mbedtls_ssl_conf_tls13_some_psk_enabled(mbedtls_ssl_context *s
  * \return 0 if at least one of the key exchange modes is supported,
  *         !=0 otherwise.
  */
-static inline unsigned mbedtls_ssl_tls13_check_kex_modes(mbedtls_ssl_context *ssl,
+static inline unsigned esp_mbedtls_ssl_tls13_check_kex_modes(mbedtls_ssl_context *ssl,
                                                          int kex_modes_mask)
 {
     return (ssl->handshake->tls13_kex_modes & kex_modes_mask) == 0;
 }
 
-static inline int mbedtls_ssl_tls13_psk_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_tls13_psk_enabled(mbedtls_ssl_context *ssl)
 {
-    return !mbedtls_ssl_tls13_check_kex_modes(ssl,
+    return !esp_mbedtls_ssl_tls13_check_kex_modes(ssl,
                                               MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK);
 }
 
-static inline int mbedtls_ssl_tls13_psk_ephemeral_enabled(
+static inline int esp_mbedtls_ssl_tls13_psk_ephemeral_enabled(
     mbedtls_ssl_context *ssl)
 {
-    return !mbedtls_ssl_tls13_check_kex_modes(ssl,
+    return !esp_mbedtls_ssl_tls13_check_kex_modes(ssl,
                                               MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL);
 }
 
-static inline int mbedtls_ssl_tls13_ephemeral_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_tls13_ephemeral_enabled(mbedtls_ssl_context *ssl)
 {
-    return !mbedtls_ssl_tls13_check_kex_modes(ssl,
+    return !esp_mbedtls_ssl_tls13_check_kex_modes(ssl,
                                               MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL);
 }
 
-static inline int mbedtls_ssl_tls13_some_ephemeral_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_tls13_some_ephemeral_enabled(mbedtls_ssl_context *ssl)
 {
-    return !mbedtls_ssl_tls13_check_kex_modes(ssl,
+    return !esp_mbedtls_ssl_tls13_check_kex_modes(ssl,
                                               MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL);
 }
 
-static inline int mbedtls_ssl_tls13_some_psk_enabled(mbedtls_ssl_context *ssl)
+static inline int esp_mbedtls_ssl_tls13_some_psk_enabled(mbedtls_ssl_context *ssl)
 {
-    return !mbedtls_ssl_tls13_check_kex_modes(ssl,
+    return !esp_mbedtls_ssl_tls13_check_kex_modes(ssl,
                                               MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL);
 }
 #endif /* MBEDTLS_SSL_SRV_C &&
@@ -2015,7 +2015,7 @@ int esp_mbedtls_ssl_tls13_check_received_extension(
     unsigned int received_extension_type,
     uint32_t hs_msg_allowed_extensions_mask);
 
-static inline void mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+static inline void esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
     mbedtls_ssl_context *ssl, unsigned int extension_type)
 {
     ssl->handshake->sent_extensions |=
@@ -2025,23 +2025,23 @@ static inline void mbedtls_ssl_tls13_set_hs_sent_ext_mask(
 /*
  * Helper functions to check the selected key exchange mode.
  */
-static inline int mbedtls_ssl_tls13_key_exchange_mode_check(
+static inline int esp_mbedtls_ssl_tls13_key_exchange_mode_check(
     mbedtls_ssl_context *ssl, int kex_mask)
 {
     return (ssl->handshake->key_exchange_mode & kex_mask) != 0;
 }
 
-static inline int mbedtls_ssl_tls13_key_exchange_mode_with_psk(
+static inline int esp_mbedtls_ssl_tls13_key_exchange_mode_with_psk(
     mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_tls13_key_exchange_mode_check(ssl,
+    return esp_mbedtls_ssl_tls13_key_exchange_mode_check(ssl,
                                                      MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL);
 }
 
-static inline int mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(
+static inline int esp_mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(
     mbedtls_ssl_context *ssl)
 {
-    return mbedtls_ssl_tls13_key_exchange_mode_check(ssl,
+    return esp_mbedtls_ssl_tls13_key_exchange_mode_check(ssl,
                                                      MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL);
 }
 
@@ -2144,7 +2144,7 @@ int esp_mbedtls_ssl_get_handshake_transcript(mbedtls_ssl_context *ssl,
  * ssl->conf->group_list when esp_mbedtls_ssl_conf_groups() has been more recently invoked.
  *
  */
-static inline const void *mbedtls_ssl_get_groups(const mbedtls_ssl_context *ssl)
+static inline const void *esp_mbedtls_ssl_get_groups(const mbedtls_ssl_context *ssl)
 {
     #if defined(MBEDTLS_DEPRECATED_REMOVED) || !defined(MBEDTLS_ECP_C)
     return ssl->conf->group_list;
@@ -2160,7 +2160,7 @@ static inline const void *mbedtls_ssl_get_groups(const mbedtls_ssl_context *ssl)
 /*
  * Helper functions for NamedGroup.
  */
-static inline int mbedtls_ssl_tls12_named_group_is_ecdhe(uint16_t named_group)
+static inline int esp_mbedtls_ssl_tls12_named_group_is_ecdhe(uint16_t named_group)
 {
     /*
      * RFC 8422 section 5.1.1
@@ -2181,7 +2181,7 @@ static inline int mbedtls_ssl_tls12_named_group_is_ecdhe(uint16_t named_group)
            named_group == MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1;
 }
 
-static inline int mbedtls_ssl_tls13_named_group_is_ecdhe(uint16_t named_group)
+static inline int esp_mbedtls_ssl_tls13_named_group_is_ecdhe(uint16_t named_group)
 {
     return named_group == MBEDTLS_SSL_IANA_TLS_GROUP_X25519    ||
            named_group == MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1 ||
@@ -2190,16 +2190,16 @@ static inline int mbedtls_ssl_tls13_named_group_is_ecdhe(uint16_t named_group)
            named_group == MBEDTLS_SSL_IANA_TLS_GROUP_X448;
 }
 
-static inline int mbedtls_ssl_tls13_named_group_is_dhe(uint16_t named_group)
+static inline int esp_mbedtls_ssl_tls13_named_group_is_dhe(uint16_t named_group)
 {
     return named_group >= MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048 &&
            named_group <= MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192;
 }
 
-static inline int mbedtls_ssl_named_group_is_offered(
+static inline int esp_mbedtls_ssl_named_group_is_offered(
     const mbedtls_ssl_context *ssl, uint16_t named_group)
 {
-    const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+    const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
 
     if (group_list == NULL) {
         return 0;
@@ -2214,10 +2214,10 @@ static inline int mbedtls_ssl_named_group_is_offered(
     return 0;
 }
 
-static inline int mbedtls_ssl_named_group_is_supported(uint16_t named_group)
+static inline int esp_mbedtls_ssl_named_group_is_supported(uint16_t named_group)
 {
 #if defined(MBEDTLS_ECDH_C)
-    if (mbedtls_ssl_tls13_named_group_is_ecdhe(named_group)) {
+    if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(named_group)) {
         if (esp_mbedtls_ssl_get_ecp_group_id_from_tls_id(named_group) !=
             MBEDTLS_ECP_DP_NONE) {
             return 1;
@@ -2241,7 +2241,7 @@ static inline int mbedtls_ssl_named_group_is_supported(uint16_t named_group)
  * been more recently invoked.
  *
  */
-static inline const void *mbedtls_ssl_get_sig_algs(
+static inline const void *esp_mbedtls_ssl_get_sig_algs(
     const mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
@@ -2263,7 +2263,7 @@ static inline const void *mbedtls_ssl_get_sig_algs(
 }
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED)
-static inline int mbedtls_ssl_sig_alg_is_received(const mbedtls_ssl_context *ssl,
+static inline int esp_mbedtls_ssl_sig_alg_is_received(const mbedtls_ssl_context *ssl,
                                                   uint16_t own_sig_alg)
 {
     const uint16_t *sig_alg = ssl->handshake->received_sig_algs;
@@ -2279,7 +2279,7 @@ static inline int mbedtls_ssl_sig_alg_is_received(const mbedtls_ssl_context *ssl
     return 0;
 }
 
-static inline int mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(
+static inline int esp_mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(
     const uint16_t sig_alg)
 {
     switch (sig_alg) {
@@ -2319,7 +2319,7 @@ static inline int mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(
 
 }
 
-static inline int mbedtls_ssl_tls13_sig_alg_is_supported(
+static inline int esp_mbedtls_ssl_tls13_sig_alg_is_supported(
     const uint16_t sig_alg)
 {
     switch (sig_alg) {
@@ -2338,7 +2338,7 @@ static inline int mbedtls_ssl_tls13_sig_alg_is_supported(
 #endif /* MBEDTLS_HAS_ALG_SHA_512_VIA_MD_OR_PSA_BASED_ON_USE_PSA */
 #endif /* MBEDTLS_PKCS1_V15 */
         default:
-            return mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(
+            return esp_mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(
                 sig_alg);
     }
     return 1;
@@ -2350,10 +2350,10 @@ int esp_mbedtls_ssl_tls13_check_sig_alg_cert_key_match(uint16_t sig_alg,
 #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED */
 
 #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
-static inline int mbedtls_ssl_sig_alg_is_offered(const mbedtls_ssl_context *ssl,
+static inline int esp_mbedtls_ssl_sig_alg_is_offered(const mbedtls_ssl_context *ssl,
                                                  uint16_t proposed_sig_alg)
 {
-    const uint16_t *sig_alg = mbedtls_ssl_get_sig_algs(ssl);
+    const uint16_t *sig_alg = esp_mbedtls_ssl_get_sig_algs(ssl);
     if (sig_alg == NULL) {
         return 0;
     }
@@ -2366,7 +2366,7 @@ static inline int mbedtls_ssl_sig_alg_is_offered(const mbedtls_ssl_context *ssl,
     return 0;
 }
 
-static inline int mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
+static inline int esp_mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
     uint16_t sig_alg, mbedtls_pk_type_t *pk_type, mbedtls_md_type_t *md_alg)
 {
     *pk_type = esp_mbedtls_ssl_pk_alg_from_sig(sig_alg & 0xff);
@@ -2404,7 +2404,7 @@ static inline int mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
 }
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-static inline int mbedtls_ssl_tls12_sig_alg_is_supported(
+static inline int esp_mbedtls_ssl_tls12_sig_alg_is_supported(
     const uint16_t sig_alg)
 {
     /* High byte is hash */
@@ -2465,20 +2465,20 @@ static inline int mbedtls_ssl_tls12_sig_alg_is_supported(
 }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
 
-static inline int mbedtls_ssl_sig_alg_is_supported(
+static inline int esp_mbedtls_ssl_sig_alg_is_supported(
     const mbedtls_ssl_context *ssl,
     const uint16_t sig_alg)
 {
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
     if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2) {
-        return mbedtls_ssl_tls12_sig_alg_is_supported(sig_alg);
+        return esp_mbedtls_ssl_tls12_sig_alg_is_supported(sig_alg);
     }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED)
     if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_3) {
-        return mbedtls_ssl_tls13_sig_alg_is_supported(sig_alg);
+        return esp_mbedtls_ssl_tls13_sig_alg_is_supported(sig_alg);
     }
 #endif
     ((void) ssl);
@@ -2526,7 +2526,7 @@ psa_status_t esp_mbedtls_ssl_cipher_to_psa(mbedtls_cipher_type_t mbedtls_cipher_
  *
  * \return             corresponding mbedtls error code
  */
-static inline MBEDTLS_DEPRECATED int psa_ssl_status_to_mbedtls(psa_status_t status)
+static inline MBEDTLS_DEPRECATED int esp_psa_ssl_status_to_mbedtls(psa_status_t status)
 {
     switch (status) {
         case PSA_SUCCESS:
@@ -2627,7 +2627,7 @@ int esp_mbedtls_ssl_tls13_read_public_ecdhe_share(mbedtls_ssl_context *ssl,
 
 #endif /* MBEDTLS_ECDH_C */
 
-static inline int mbedtls_ssl_tls13_cipher_suite_is_offered(
+static inline int esp_mbedtls_ssl_tls13_cipher_suite_is_offered(
     mbedtls_ssl_context *ssl, int cipher_suite)
 {
     const int *ciphersuite_list = ssl->conf->ciphersuite_list;
@@ -2742,20 +2742,20 @@ int esp_mbedtls_ssl_session_set_hostname(mbedtls_ssl_session *session,
 #endif
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3) && defined(MBEDTLS_SSL_SESSION_TICKETS)
-static inline unsigned int mbedtls_ssl_session_get_ticket_flags(
+static inline unsigned int esp_mbedtls_ssl_session_get_ticket_flags(
     mbedtls_ssl_session *session, unsigned int flags)
 {
     return session->ticket_flags &
            (flags & MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK);
 }
 
-static inline void mbedtls_ssl_session_set_ticket_flags(
+static inline void esp_mbedtls_ssl_session_set_ticket_flags(
     mbedtls_ssl_session *session, unsigned int flags)
 {
     session->ticket_flags |= (flags & MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK);
 }
 
-static inline void mbedtls_ssl_session_clear_ticket_flags(
+static inline void esp_mbedtls_ssl_session_clear_ticket_flags(
     mbedtls_ssl_session *session, unsigned int flags)
 {
     session->ticket_flags &= ~(flags & MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK);
diff --git a/library/ssl_msg.c b/library/ssl_msg.c
index bb32fc0fdab8dd285251974c431fda6662420e72..d383c66fd5ee2ec43a76d4253f40a265a3ecfdb5 100644
--- a/library/ssl_msg.c
+++ b/library/ssl_msg.c
@@ -674,7 +674,7 @@ static void esp_ssl_build_record_nonce(unsigned char *dst_iv,
     memcpy(dst_iv, fixed_iv, fixed_iv_len);
 
     dst_iv += dst_iv_len - dynamic_iv_len;
-    mbedtls_xor(dst_iv, dst_iv, dynamic_iv, dynamic_iv_len);
+    esp_mbedtls_xor(dst_iv, dst_iv, dynamic_iv, dynamic_iv_len);
 }
 #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
 
@@ -2137,7 +2137,7 @@ int esp_mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl)
     while (ssl->out_left > 0) {
         MBEDTLS_SSL_DEBUG_MSG(2, ("message length: %" MBEDTLS_PRINTF_SIZET
                                   ", out_left: %" MBEDTLS_PRINTF_SIZET,
-                                  mbedtls_ssl_out_hdr_len(ssl) + ssl->out_msglen, ssl->out_left));
+                                  esp_mbedtls_ssl_out_hdr_len(ssl) + ssl->out_msglen, ssl->out_left));
 
         buf = ssl->out_hdr - ssl->out_left;
         ret = ssl->f_send(ssl->p_bio, buf, ssl->out_left);
@@ -2774,7 +2774,7 @@ int esp_mbedtls_ssl_write_record(mbedtls_ssl_context *ssl, int force_flush)
             MBEDTLS_PUT_UINT16_BE(rec.data_len, ssl->out_len, 0);
         }
 
-        protected_record_size = len + mbedtls_ssl_out_hdr_len(ssl);
+        protected_record_size = len + esp_mbedtls_ssl_out_hdr_len(ssl);
 
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
         /* In case of DTLS, double-check that we don't exceed
@@ -2807,14 +2807,14 @@ int esp_mbedtls_ssl_write_record(mbedtls_ssl_context *ssl, int force_flush)
         ssl->out_hdr  += protected_record_size;
         esp_mbedtls_ssl_update_out_pointers(ssl, ssl->transform_out);
 
-        for (i = 8; i > mbedtls_ssl_ep_len(ssl); i--) {
+        for (i = 8; i > esp_mbedtls_ssl_ep_len(ssl); i--) {
             if (++ssl->cur_out_ctr[i - 1] != 0) {
                 break;
             }
         }
 
         /* The loop goes to its end if the counter is wrapping */
-        if (i == mbedtls_ssl_ep_len(ssl)) {
+        if (i == esp_mbedtls_ssl_ep_len(ssl)) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("outgoing message counter would wrap"));
             return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
         }
@@ -2997,13 +2997,13 @@ static uint32_t esp_ssl_get_hs_total_len(mbedtls_ssl_context const *ssl)
 
 int esp_mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl)
 {
-    if (ssl->in_msglen < mbedtls_ssl_hs_hdr_len(ssl)) {
+    if (ssl->in_msglen < esp_mbedtls_ssl_hs_hdr_len(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("handshake message too short: %" MBEDTLS_PRINTF_SIZET,
                                   ssl->in_msglen));
         return MBEDTLS_ERR_SSL_INVALID_RECORD;
     }
 
-    ssl->in_hslen = mbedtls_ssl_hs_hdr_len(ssl) + esp_ssl_get_hs_total_len(ssl);
+    ssl->in_hslen = esp_mbedtls_ssl_hs_hdr_len(ssl) + esp_ssl_get_hs_total_len(ssl);
 
     MBEDTLS_SSL_DEBUG_MSG(3, ("handshake message: msglen ="
                               " %" MBEDTLS_PRINTF_SIZET ", type = %u, hslen = %"
@@ -3832,14 +3832,14 @@ static int esp_ssl_prepare_record_content(mbedtls_ssl_context *ssl,
         {
             unsigned i;
             for (i = MBEDTLS_SSL_SEQUENCE_NUMBER_LEN;
-                 i > mbedtls_ssl_ep_len(ssl); i--) {
+                 i > esp_mbedtls_ssl_ep_len(ssl); i--) {
                 if (++ssl->in_ctr[i - 1] != 0) {
                     break;
                 }
             }
 
             /* The loop goes to its end iff the counter is wrapping */
-            if (i == mbedtls_ssl_ep_len(ssl)) {
+            if (i == esp_mbedtls_ssl_ep_len(ssl)) {
                 MBEDTLS_SSL_DEBUG_MSG(1, ("incoming message counter would wrap"));
                 return MBEDTLS_ERR_SSL_COUNTER_WRAPPING;
             }
@@ -4556,7 +4556,7 @@ static int esp_ssl_get_next_record(mbedtls_ssl_context *ssl)
     /* Ensure that we have enough space available for the default form
      * of TLS / DTLS record headers (5 Bytes for TLS, 13 Bytes for DTLS,
      * with no space for CIDs counted in). */
-    ret = esp_mbedtls_ssl_fetch_input(ssl, mbedtls_ssl_in_hdr_len(ssl));
+    ret = esp_mbedtls_ssl_fetch_input(ssl, esp_mbedtls_ssl_in_hdr_len(ssl));
     if (ret != 0) {
         MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_fetch_input", ret);
         return ret;
@@ -4894,8 +4894,8 @@ int esp_mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl)
 
     ssl->state++;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -5152,7 +5152,7 @@ int esp_mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context *ssl)
     psa_key_type_t key_type;
 #endif /* MBEDTLS_USE_PSA_CRYPTO */
 
-    size_t out_hdr_len = mbedtls_ssl_out_hdr_len(ssl);
+    size_t out_hdr_len = esp_mbedtls_ssl_out_hdr_len(ssl);
 
     if (transform == NULL) {
         return (int) out_hdr_len;
@@ -5242,7 +5242,7 @@ int esp_mbedtls_ssl_get_record_expansion(const mbedtls_ssl_context *ssl)
 MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_check_ctr_renegotiate(mbedtls_ssl_context *ssl)
 {
-    size_t ep_len = mbedtls_ssl_ep_len(ssl);
+    size_t ep_len = esp_mbedtls_ssl_ep_len(ssl);
     int in_ctr_cmp;
     int out_ctr_cmp;
 
@@ -5275,7 +5275,7 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_tls13_check_new_session_ticket(mbedtls_ssl_context *ssl)
 {
 
-    if ((ssl->in_hslen == mbedtls_ssl_hs_hdr_len(ssl)) ||
+    if ((ssl->in_hslen == esp_mbedtls_ssl_hs_hdr_len(ssl)) ||
         (ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET)) {
         return 0;
     }
@@ -5283,7 +5283,7 @@ static int esp_ssl_tls13_check_new_session_ticket(mbedtls_ssl_context *ssl)
     ssl->keep_current_message = 1;
 
     MBEDTLS_SSL_DEBUG_MSG(3, ("NewSessionTicket received"));
-    mbedtls_ssl_handshake_set_state(ssl,
+    esp_mbedtls_ssl_handshake_set_state(ssl,
                                     MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
 
     return MBEDTLS_ERR_SSL_WANT_READ;
@@ -5334,7 +5334,7 @@ static int esp_ssl_tls12_handle_hs_message_post_handshake(mbedtls_ssl_context *s
 #if defined(MBEDTLS_SSL_CLI_C)
     if (ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
         (ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
-         ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl))) {
+         ssl->in_hslen  != esp_mbedtls_ssl_hs_hdr_len(ssl))) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("handshake received (not HelloRequest)"));
 
         /* With DTLS, drop the packet (probably from last handshake) */
diff --git a/library/ssl_tls.c b/library/ssl_tls.c
index 679885b33d6d780869d50931997af246fb0e10f5..50a939a3d2751f366f973f2c3fa8d6ea5de09e3f 100644
--- a/library/ssl_tls.c
+++ b/library/ssl_tls.c
@@ -1192,7 +1192,7 @@ static int esp_ssl_handshake_init(mbedtls_ssl_context *ssl)
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
     /* Heap allocate and translate sig_hashes from internal hash identifiers to
        signature algorithms IANA identifiers.  */
-    if (mbedtls_ssl_conf_is_tls12_only(ssl->conf) &&
+    if (esp_mbedtls_ssl_conf_is_tls12_only(ssl->conf) &&
         ssl->conf->sig_hashes != NULL) {
         const int *md;
         const int *sig_hashes = ssl->conf->sig_hashes;
@@ -1301,7 +1301,7 @@ static int esp_ssl_conf_version_check(const mbedtls_ssl_context *ssl)
     const mbedtls_ssl_config *conf = ssl->conf;
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    if (mbedtls_ssl_conf_is_tls13_only(conf)) {
+    if (esp_mbedtls_ssl_conf_is_tls13_only(conf)) {
         if (conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS 1.3 is not yet supported."));
             return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
@@ -1313,14 +1313,14 @@ static int esp_ssl_conf_version_check(const mbedtls_ssl_context *ssl)
 #endif
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-    if (mbedtls_ssl_conf_is_tls12_only(conf)) {
+    if (esp_mbedtls_ssl_conf_is_tls12_only(conf)) {
         MBEDTLS_SSL_DEBUG_MSG(4, ("The SSL configuration is tls12 only."));
         return 0;
     }
 #endif
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    if (mbedtls_ssl_conf_is_hybrid_tls12_tls13(conf)) {
+    if (esp_mbedtls_ssl_conf_is_hybrid_tls12_tls13(conf)) {
         if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("DTLS not yet supported in Hybrid TLS 1.3 + TLS 1.2"));
             return MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
@@ -1360,7 +1360,7 @@ static int esp_ssl_conf_check(const mbedtls_ssl_context *ssl)
      * bad config.
      *
      */
-    if (mbedtls_ssl_conf_tls13_ephemeral_enabled(
+    if (esp_mbedtls_ssl_conf_tls13_ephemeral_enabled(
             (mbedtls_ssl_context *) ssl)                            &&
         ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT                &&
         ssl->conf->max_tls_version == MBEDTLS_SSL_VERSION_TLS1_3    &&
@@ -3083,7 +3083,7 @@ int esp_mbedtls_ssl_conf_dtls_srtp_protection_profiles(mbedtls_ssl_config *conf,
     for (p = profiles; *p != MBEDTLS_TLS_SRTP_UNSET &&
          list_size <= MBEDTLS_TLS_SRTP_MAX_PROFILE_LIST_LENGTH;
          p++) {
-        if (mbedtls_ssl_check_srtp_profile_value(*p) != MBEDTLS_TLS_SRTP_UNSET) {
+        if (esp_mbedtls_ssl_check_srtp_profile_value(*p) != MBEDTLS_TLS_SRTP_UNSET) {
             list_size++;
         } else {
             /* unsupported value, stop parsing and set the size to an error value */
@@ -3887,13 +3887,13 @@ int esp_mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl)
 #if defined(MBEDTLS_SSL_SRV_C)
     if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-        if (mbedtls_ssl_conf_is_tls13_only(ssl->conf)) {
+        if (esp_mbedtls_ssl_conf_is_tls13_only(ssl->conf)) {
             ret = esp_mbedtls_ssl_tls13_handshake_server_step(ssl);
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-        if (mbedtls_ssl_conf_is_tls12_only(ssl->conf)) {
+        if (esp_mbedtls_ssl_conf_is_tls12_only(ssl->conf)) {
             ret = esp_mbedtls_ssl_handshake_server_step(ssl);
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
@@ -3968,8 +3968,8 @@ static int esp_ssl_write_hello_request(mbedtls_ssl_context *ssl)
     ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
     ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -4242,8 +4242,8 @@ void esp_mbedtls_ssl_handshake_free(mbedtls_ssl_context *ssl)
      * processes datagrams and the fact that a datagram is allowed to have
      * several records in it, it is possible that the I/O buffers are not
      * empty at this stage */
-    esp_handle_buffer_resizing(ssl, 1, mbedtls_ssl_get_input_buflen(ssl),
-                           mbedtls_ssl_get_output_buflen(ssl));
+    esp_handle_buffer_resizing(ssl, 1, esp_mbedtls_ssl_get_input_buflen(ssl),
+                           esp_mbedtls_ssl_get_output_buflen(ssl));
 #endif
 
     /* esp_mbedtls_platform_zeroize MUST be last one in this function */
@@ -4411,7 +4411,7 @@ int esp_mbedtls_ssl_context_save(mbedtls_ssl_context *ssl,
         return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
     }
     /* We must be using an AEAD ciphersuite */
-    if (mbedtls_ssl_transform_uses_aead(ssl->transform) != 1) {
+    if (esp_mbedtls_ssl_transform_uses_aead(ssl->transform) != 1) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("Only AEAD ciphersuites supported"));
         return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
     }
@@ -5341,7 +5341,7 @@ int esp_mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf,
 
 #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-            if (mbedtls_ssl_conf_is_tls12_only(conf)) {
+            if (esp_mbedtls_ssl_conf_is_tls12_only(conf)) {
                 conf->sig_algs = esp_ssl_tls12_preset_suiteb_sig_algs;
             } else
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
@@ -5367,7 +5367,7 @@ int esp_mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf,
 
 #if defined(MBEDTLS_SSL_HANDSHAKE_WITH_CERT_ENABLED)
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
-            if (mbedtls_ssl_conf_is_tls12_only(conf)) {
+            if (esp_mbedtls_ssl_conf_is_tls12_only(conf)) {
                 conf->sig_algs = esp_ssl_tls12_preset_default_sig_algs;
             } else
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
@@ -5551,7 +5551,7 @@ unsigned char esp_mbedtls_ssl_hash_from_md_alg(int md)
  */
 int esp_mbedtls_ssl_check_curve_tls_id(const mbedtls_ssl_context *ssl, uint16_t tls_id)
 {
-    const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+    const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
 
     if (group_list == NULL) {
         return -1;
@@ -5985,8 +5985,8 @@ int esp_mbedtls_ssl_parse_sig_alg_ext(mbedtls_ssl_context *ssl,
                                   esp_mbedtls_ssl_sig_alg_to_str(sig_alg)));
 #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
         if (ssl->tls_version == MBEDTLS_SSL_VERSION_TLS1_2 &&
-            (!(mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg) &&
-               mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg)))) {
+            (!(esp_mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg) &&
+               esp_mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg)))) {
             continue;
         }
 #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
@@ -6424,7 +6424,7 @@ static int esp_ssl_compute_master(mbedtls_ssl_handshake_params *handshake,
 
         MBEDTLS_SSL_DEBUG_MSG(2, ("perform PSA-based PSK-to-MS expansion"));
 
-        psk = mbedtls_ssl_get_opaque_psk(ssl);
+        psk = esp_mbedtls_ssl_get_opaque_psk(ssl);
 
         if (hash_alg == MBEDTLS_MD_SHA384) {
             alg = PSA_ALG_TLS12_PSK_TO_MS(PSA_ALG_SHA_384);
@@ -6763,7 +6763,7 @@ int esp_mbedtls_ssl_psk_derive_premaster(mbedtls_ssl_context *ssl, mbedtls_key_e
     unsigned char *end = p + sizeof(ssl->handshake->premaster);
     const unsigned char *psk = NULL;
     size_t psk_len = 0;
-    int psk_ret = mbedtls_ssl_get_psk(ssl, &psk, &psk_len);
+    int psk_ret = esp_mbedtls_ssl_get_psk(ssl, &psk, &psk_len);
 
     if (psk_ret == MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) {
         /*
@@ -6979,7 +6979,7 @@ int esp_mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
 #endif /* MBEDTLS_SSL_CLI_C */
 #if defined(MBEDTLS_SSL_SRV_C)
     if (ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER) {
-        if (mbedtls_ssl_own_cert(ssl) == NULL) {
+        if (esp_mbedtls_ssl_own_cert(ssl) == NULL) {
             /* Should never happen because we shouldn't have picked the
              * ciphersuite if we don't have a certificate. */
             return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
@@ -6987,7 +6987,7 @@ int esp_mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
     }
 #endif
 
-    MBEDTLS_SSL_DEBUG_CRT(3, "own certificate", mbedtls_ssl_own_cert(ssl));
+    MBEDTLS_SSL_DEBUG_CRT(3, "own certificate", esp_mbedtls_ssl_own_cert(ssl));
 
     /*
      *     0  .  0    handshake type
@@ -6999,7 +6999,7 @@ int esp_mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
      *    n+3 . ...   upper level cert, etc.
      */
     i = 7;
-    crt = mbedtls_ssl_own_cert(ssl);
+    crt = esp_mbedtls_ssl_own_cert(ssl);
 
     while (crt != NULL) {
         n = crt->raw.len;
@@ -7028,8 +7028,8 @@ int esp_mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)
 
     ssl->state++;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -7121,14 +7121,14 @@ static int esp_ssl_parse_certificate_chain(mbedtls_ssl_context *ssl,
         return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
     }
 
-    if (ssl->in_hslen < mbedtls_ssl_hs_hdr_len(ssl) + 3 + 3) {
+    if (ssl->in_hslen < esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 + 3) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
         return MBEDTLS_ERR_SSL_DECODE_ERROR;
     }
 
-    i = mbedtls_ssl_hs_hdr_len(ssl);
+    i = esp_mbedtls_ssl_hs_hdr_len(ssl);
 
     /*
      * Same message structure as in esp_mbedtls_ssl_write_certificate()
@@ -7136,7 +7136,7 @@ static int esp_ssl_parse_certificate_chain(mbedtls_ssl_context *ssl,
     n = (ssl->in_msg[i+1] << 8) | ssl->in_msg[i+2];
 
     if (ssl->in_msg[i] != 0 ||
-        ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len(ssl)) {
+        ssl->in_hslen != n + 3 + esp_mbedtls_ssl_hs_hdr_len(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
@@ -7250,10 +7250,10 @@ static int esp_ssl_srv_check_client_no_crt_notification(mbedtls_ssl_context *ssl
         return -1;
     }
 
-    if (ssl->in_hslen   == 3 + mbedtls_ssl_hs_hdr_len(ssl) &&
+    if (ssl->in_hslen   == 3 + esp_mbedtls_ssl_hs_hdr_len(ssl) &&
         ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
         ssl->in_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
-        memcmp(ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl), "\0\0\0", 3) == 0) {
+        memcmp(ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl), "\0\0\0", 3) == 0) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("peer has no certificate"));
         return 0;
     }
@@ -8049,8 +8049,8 @@ int esp_mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl)
     }
 #endif
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -8102,7 +8102,7 @@ int esp_mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)
         goto exit;
     }
 
-    if (ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl) + hash_len) {
+    if (ssl->in_hslen  != esp_mbedtls_ssl_hs_hdr_len(ssl) + hash_len) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad finished message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
@@ -8110,7 +8110,7 @@ int esp_mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)
         goto exit;
     }
 
-    if (esp_mbedtls_ct_memcmp(ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl),
+    if (esp_mbedtls_ct_memcmp(ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl),
                           buf, hash_len) != 0) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad finished message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -9408,7 +9408,7 @@ int esp_mbedtls_ssl_write_sig_alg_ext(mbedtls_ssl_context *ssl, unsigned char *b
      * Write supported_signature_algorithms
      */
     supported_sig_alg = p;
-    const uint16_t *sig_alg = mbedtls_ssl_get_sig_algs(ssl);
+    const uint16_t *sig_alg = esp_mbedtls_ssl_get_sig_algs(ssl);
     if (sig_alg == NULL) {
         return MBEDTLS_ERR_SSL_BAD_CONFIG;
     }
@@ -9417,7 +9417,7 @@ int esp_mbedtls_ssl_write_sig_alg_ext(mbedtls_ssl_context *ssl, unsigned char *b
         MBEDTLS_SSL_DEBUG_MSG(3, ("got signature scheme [%x] %s",
                                   *sig_alg,
                                   esp_mbedtls_ssl_sig_alg_to_str(*sig_alg)));
-        if (!mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
+        if (!esp_mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
             continue;
         }
         MBEDTLS_SSL_CHK_BUF_PTR(p, end, 2);
@@ -9442,7 +9442,7 @@ int esp_mbedtls_ssl_write_sig_alg_ext(mbedtls_ssl_context *ssl, unsigned char *b
     *out_len = p - buf;
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SIG_ALG);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_SIG_ALG);
 #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
 
     return 0;
@@ -9638,7 +9638,7 @@ int esp_mbedtls_ssl_write_alpn_ext(mbedtls_ssl_context *ssl,
     memcpy(p + 7, ssl->alpn_chosen, protocol_name_len);
 
 #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_ALPN);
 #endif
 
     return 0;
diff --git a/library/ssl_tls12_client.c b/library/ssl_tls12_client.c
index 8f3b3f6f9d4087fe7063e0bcc27bc37ef70d5a78..95f9dd0ed9f17dba6135bc963aa31a7a05e5fb78 100644
--- a/library/ssl_tls12_client.c
+++ b/library/ssl_tls12_client.c
@@ -466,7 +466,7 @@ static int esp_ssl_write_use_srtp_ext(mbedtls_ssl_context *ssl,
     for (protection_profiles_index = 0;
          protection_profiles_index < ssl->conf->dtls_srtp_profile_list_len;
          protection_profiles_index++) {
-        profile_value = mbedtls_ssl_check_srtp_profile_value
+        profile_value = esp_mbedtls_ssl_check_srtp_profile_value
                             (ssl->conf->dtls_srtp_profile_list[protection_profiles_index]);
         if (profile_value != MBEDTLS_TLS_SRTP_UNSET) {
             MBEDTLS_SSL_DEBUG_MSG(3, ("esp_ssl_write_use_srtp_ext, add profile: %04x",
@@ -1028,7 +1028,7 @@ static int esp_ssl_parse_use_srtp_ext(mbedtls_ssl_context *ssl,
     }
 
     server_protection_profile_value = (buf[2] << 8) | buf[3];
-    server_protection = mbedtls_ssl_check_srtp_profile_value(
+    server_protection = esp_mbedtls_ssl_check_srtp_profile_value(
         server_protection_profile_value);
     if (server_protection != MBEDTLS_TLS_SRTP_UNSET) {
         MBEDTLS_SSL_DEBUG_MSG(3, ("found srtp profile: %s",
@@ -1094,7 +1094,7 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_parse_hello_verify_request(mbedtls_ssl_context *ssl)
 {
     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
-    const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
+    const unsigned char *p = ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl);
     uint16_t dtls_legacy_version;
 
 #if !defined(MBEDTLS_SSL_PROTO_TLS1_3)
@@ -1109,7 +1109,7 @@ static int esp_ssl_parse_hello_verify_request(mbedtls_ssl_context *ssl)
      * - 2 bytes of version
      * - 1 byte of cookie_len
      */
-    if (mbedtls_ssl_hs_hdr_len(ssl) + 3 > ssl->in_msglen) {
+    if (esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 > ssl->in_msglen) {
         MBEDTLS_SSL_DEBUG_MSG(1,
                               ("incoming HelloVerifyRequest message is too short"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -1245,7 +1245,7 @@ static int esp_ssl_parse_server_hello(mbedtls_ssl_context *ssl)
     }
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
 
-    if (ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len(ssl) ||
+    if (ssl->in_hslen < 38 + esp_mbedtls_ssl_hs_hdr_len(ssl) ||
         buf[0] != MBEDTLS_SSL_HS_SERVER_HELLO) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -1264,7 +1264,7 @@ static int esp_ssl_parse_server_hello(mbedtls_ssl_context *ssl)
      * 38+n . 39+n  extensions length (optional)
      * 40+n .  ..   extensions
      */
-    buf += mbedtls_ssl_hs_hdr_len(ssl);
+    buf += esp_mbedtls_ssl_hs_hdr_len(ssl);
 
     MBEDTLS_SSL_DEBUG_BUF(3, "server hello, version", buf, 2);
     ssl->tls_version = esp_mbedtls_ssl_read_version(buf, ssl->conf->transport);
@@ -1304,12 +1304,12 @@ static int esp_ssl_parse_server_hello(mbedtls_ssl_context *ssl)
         return MBEDTLS_ERR_SSL_DECODE_ERROR;
     }
 
-    if (ssl->in_hslen > mbedtls_ssl_hs_hdr_len(ssl) + 39 + n) {
+    if (ssl->in_hslen > esp_mbedtls_ssl_hs_hdr_len(ssl) + 39 + n) {
         ext_len = ((buf[38 + n] <<  8)
                    | (buf[39 + n]));
 
         if ((ext_len > 0 && ext_len < 4) ||
-            ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 40 + n + ext_len) {
+            ssl->in_hslen != esp_mbedtls_ssl_hs_hdr_len(ssl) + 40 + n + ext_len) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
             esp_mbedtls_ssl_send_alert_message(
                 ssl,
@@ -1317,7 +1317,7 @@ static int esp_ssl_parse_server_hello(mbedtls_ssl_context *ssl)
                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
             return MBEDTLS_ERR_SSL_DECODE_ERROR;
         }
-    } else if (ssl->in_hslen == mbedtls_ssl_hs_hdr_len(ssl) + 38 + n) {
+    } else if (ssl->in_hslen == esp_mbedtls_ssl_hs_hdr_len(ssl) + 38 + n) {
         ext_len = 0;
     } else {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello message"));
@@ -2164,7 +2164,7 @@ static int esp_ssl_parse_server_key_exchange(mbedtls_ssl_context *ssl)
 
 start_processing:
 #endif
-    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
+    p   = ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl);
     end = ssl->in_msg + ssl->in_hslen;
     MBEDTLS_SSL_DEBUG_BUF(3,   "server key exchange", p, end - p);
 
@@ -2290,7 +2290,7 @@ start_processing:
 
         mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
         mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
-        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
+        unsigned char *params = ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl);
         size_t params_len = p - params;
         void *rs_ctx = NULL;
         uint16_t sig_alg;
@@ -2313,10 +2313,10 @@ start_processing:
          */
         MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
         sig_alg = MBEDTLS_GET_UINT16_BE(p, 0);
-        if (mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
+        if (esp_mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
                 sig_alg, &pk_alg, &md_alg) != 0 &&
-            !mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg) &&
-            !mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg)) {
+            !esp_mbedtls_ssl_sig_alg_is_offered(ssl, sig_alg) &&
+            !esp_mbedtls_ssl_sig_alg_is_supported(ssl, sig_alg)) {
             MBEDTLS_SSL_DEBUG_MSG(1,
                                   ("bad server key exchange message"));
             esp_mbedtls_ssl_send_alert_message(
@@ -2550,13 +2550,13 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
     buf = ssl->in_msg;
 
     /* certificate_types */
-    if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl)) {
+    if (ssl->in_hslen <= esp_mbedtls_ssl_hs_hdr_len(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
         return MBEDTLS_ERR_SSL_DECODE_ERROR;
     }
-    cert_type_len = buf[mbedtls_ssl_hs_hdr_len(ssl)];
+    cert_type_len = buf[esp_mbedtls_ssl_hs_hdr_len(ssl)];
     n = cert_type_len;
 
     /*
@@ -2569,7 +2569,7 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
      * therefore the buffer length at this point must be greater than that
      * regardless of the actual code path.
      */
-    if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 2 + n) {
+    if (ssl->in_hslen <= esp_mbedtls_ssl_hs_hdr_len(ssl) + 2 + n) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
@@ -2577,8 +2577,8 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
     }
 
     /* supported_signature_algorithms */
-    sig_alg_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
-                   | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
+    sig_alg_len = ((buf[esp_mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
+                   | (buf[esp_mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
 
     /*
      * The furthest access in buf is in the loop few lines below:
@@ -2592,7 +2592,7 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
      *     buf[...hdr_len + 3 + n + sig_alg_len],
      * which is one less than we need the buf to be.
      */
-    if (ssl->in_hslen <= mbedtls_ssl_hs_hdr_len(ssl) + 3 + n + sig_alg_len) {
+    if (ssl->in_hslen <= esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 + n + sig_alg_len) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
         esp_mbedtls_ssl_send_alert_message(
             ssl,
@@ -2602,7 +2602,7 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
     }
 
 #if defined(MBEDTLS_DEBUG_C)
-    sig_alg = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n;
+    sig_alg = buf + esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 + n;
     for (size_t i = 0; i < sig_alg_len; i += 2) {
         MBEDTLS_SSL_DEBUG_MSG(3,
                               ("Supported Signature Algorithm found: %02x %02x",
@@ -2613,11 +2613,11 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
     n += 2 + sig_alg_len;
 
     /* certificate_authorities */
-    dn_len = ((buf[mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
-              | (buf[mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
+    dn_len = ((buf[esp_mbedtls_ssl_hs_hdr_len(ssl) + 1 + n] <<  8)
+              | (buf[esp_mbedtls_ssl_hs_hdr_len(ssl) + 2 + n]));
 
     n += dn_len;
-    if (ssl->in_hslen != mbedtls_ssl_hs_hdr_len(ssl) + 3 + n) {
+    if (ssl->in_hslen != esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 + n) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad certificate request message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
@@ -2625,7 +2625,7 @@ static int esp_ssl_parse_certificate_request(mbedtls_ssl_context *ssl)
     }
 
 #if defined(MBEDTLS_DEBUG_C)
-    dn = buf + mbedtls_ssl_hs_hdr_len(ssl) + 3 + n - dn_len;
+    dn = buf + esp_mbedtls_ssl_hs_hdr_len(ssl) + 3 + n - dn_len;
     for (size_t i = 0, dni_len = 0; i < dn_len; i += 2 + dni_len) {
         unsigned char *p = dn + i + 2;
         mbedtls_x509_name name;
@@ -2675,7 +2675,7 @@ static int esp_ssl_parse_server_hello_done(mbedtls_ssl_context *ssl)
         return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
     }
 
-    if (ssl->in_hslen  != mbedtls_ssl_hs_hdr_len(ssl) ||
+    if (ssl->in_hslen  != esp_mbedtls_ssl_hs_hdr_len(ssl) ||
         ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad server hello done message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
@@ -3195,8 +3195,8 @@ ecdh_calc_secret:
 
     ssl->state++;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -3269,13 +3269,13 @@ static int esp_ssl_write_certificate_verify(mbedtls_ssl_context *ssl)
     }
 
     if (ssl->handshake->client_auth == 0 ||
-        mbedtls_ssl_own_cert(ssl) == NULL) {
+        esp_mbedtls_ssl_own_cert(ssl) == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(2, ("<= skip write certificate verify"));
         ssl->state++;
         return 0;
     }
 
-    if (mbedtls_ssl_own_key(ssl) == NULL) {
+    if (esp_mbedtls_ssl_own_key(ssl) == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("got no private key for certificate"));
         return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
     }
@@ -3320,7 +3320,7 @@ sign:
         md_alg = MBEDTLS_MD_SHA256;
         ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;
     }
-    ssl->out_msg[5] = esp_mbedtls_ssl_sig_from_pk(mbedtls_ssl_own_key(ssl));
+    ssl->out_msg[5] = esp_mbedtls_ssl_sig_from_pk(esp_mbedtls_ssl_own_key(ssl));
 
     /* Info from md_alg will be used instead */
     hashlen = 0;
@@ -3332,7 +3332,7 @@ sign:
     }
 #endif
 
-    if ((ret = esp_mbedtls_pk_sign_restartable(mbedtls_ssl_own_key(ssl),
+    if ((ret = esp_mbedtls_pk_sign_restartable(esp_mbedtls_ssl_own_key(ssl),
                                            md_alg, hash_start, hashlen,
                                            ssl->out_msg + 6 + offset,
                                            out_buf_len - 6 - offset,
@@ -3355,8 +3355,8 @@ sign:
 
     ssl->state++;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -3403,21 +3403,21 @@ static int esp_ssl_parse_new_session_ticket(mbedtls_ssl_context *ssl)
      * 6  .  5+n ticket content
      */
     if (ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||
-        ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len(ssl)) {
+        ssl->in_hslen < 6 + esp_mbedtls_ssl_hs_hdr_len(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
         return MBEDTLS_ERR_SSL_DECODE_ERROR;
     }
 
-    msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
+    msg = ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl);
 
     lifetime = (((uint32_t) msg[0]) << 24) | (msg[1] << 16) |
                (msg[2] << 8) | (msg[3]);
 
     ticket_len = (msg[4] << 8) | (msg[5]);
 
-    if (ticket_len + 6 + mbedtls_ssl_hs_hdr_len(ssl) != ssl->in_hslen) {
+    if (ticket_len + 6 + esp_mbedtls_ssl_hs_hdr_len(ssl) != ssl->in_hslen) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad new session ticket message"));
         esp_mbedtls_ssl_send_alert_message(ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR);
diff --git a/library/ssl_tls12_server.c b/library/ssl_tls12_server.c
index 0041dc7e9781be43fa6ba62c42ca97e5041fc046..8611f158d79485f8b16633c4443b2c434e532023 100644
--- a/library/ssl_tls12_server.c
+++ b/library/ssl_tls12_server.c
@@ -605,7 +605,7 @@ static int esp_ssl_parse_use_srtp_ext(mbedtls_ssl_context *ssl,
      */
     for (j = 0; j < profile_length; j += 2) {
         uint16_t protection_profile_value = buf[j] << 8 | buf[j + 1];
-        client_protection = mbedtls_ssl_check_srtp_profile_value(protection_profile_value);
+        client_protection = esp_mbedtls_ssl_check_srtp_profile_value(protection_profile_value);
 
         if (client_protection != MBEDTLS_TLS_SRTP_UNSET) {
             MBEDTLS_SSL_DEBUG_MSG(3, ("found srtp profile: %s",
@@ -937,7 +937,7 @@ read_record_header:
 
     buf = ssl->in_hdr;
 
-    MBEDTLS_SSL_DEBUG_BUF(4, "record header", buf, mbedtls_ssl_in_hdr_len(ssl));
+    MBEDTLS_SSL_DEBUG_BUF(4, "record header", buf, esp_mbedtls_ssl_in_hdr_len(ssl));
 
     /*
      * TLS Client Hello
@@ -1008,7 +1008,7 @@ read_record_header:
         }
 
         if ((ret = esp_mbedtls_ssl_fetch_input(ssl,
-                                           mbedtls_ssl_in_hdr_len(ssl) + msg_len)) != 0) {
+                                           esp_mbedtls_ssl_in_hdr_len(ssl) + msg_len)) != 0) {
             MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_fetch_input", ret);
             return ret;
         }
@@ -1016,7 +1016,7 @@ read_record_header:
         /* Done reading this record, get ready for the next one */
 #if defined(MBEDTLS_SSL_PROTO_DTLS)
         if (ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM) {
-            ssl->next_record_offset = msg_len + mbedtls_ssl_in_hdr_len(ssl);
+            ssl->next_record_offset = msg_len + esp_mbedtls_ssl_in_hdr_len(ssl);
         } else
 #endif
         ssl->in_left = 0;
@@ -1040,7 +1040,7 @@ read_record_header:
      *     6  .   8   DTLS only: fragment offset
      *     9  .  11   DTLS only: fragment length
      */
-    if (msg_len < mbedtls_ssl_hs_hdr_len(ssl)) {
+    if (msg_len < esp_mbedtls_ssl_hs_hdr_len(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message"));
         return MBEDTLS_ERR_SSL_DECODE_ERROR;
     }
@@ -1065,10 +1065,10 @@ read_record_header:
         }
 
         /* We don't support fragmentation of ClientHello (yet?) */
-        if (msg_len != mbedtls_ssl_hs_hdr_len(ssl) + handshake_len) {
+        if (msg_len != esp_mbedtls_ssl_hs_hdr_len(ssl) + handshake_len) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("bad client hello message: %u != %u + %u",
                                       (unsigned) msg_len,
-                                      (unsigned) mbedtls_ssl_hs_hdr_len(ssl),
+                                      (unsigned) esp_mbedtls_ssl_hs_hdr_len(ssl),
                                       (unsigned) handshake_len));
             return MBEDTLS_ERR_SSL_DECODE_ERROR;
         }
@@ -1123,8 +1123,8 @@ read_record_header:
     }
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
 
-    buf += mbedtls_ssl_hs_hdr_len(ssl);
-    msg_len -= mbedtls_ssl_hs_hdr_len(ssl);
+    buf += esp_mbedtls_ssl_hs_hdr_len(ssl);
+    msg_len -= esp_mbedtls_ssl_hs_hdr_len(ssl);
 
     /*
      * ClientHello layer:
@@ -2015,7 +2015,7 @@ static void esp_ssl_write_use_srtp_ext(mbedtls_ssl_context *ssl,
     /* protection profile length: 2 */
     buf[4] = 0x00;
     buf[5] = 0x02;
-    profile_value = mbedtls_ssl_check_srtp_profile_value(
+    profile_value = esp_mbedtls_ssl_check_srtp_profile_value(
         ssl->dtls_srtp_info.chosen_dtls_srtp_profile);
     if (profile_value != MBEDTLS_TLS_SRTP_UNSET) {
         MBEDTLS_PUT_UINT16_BE(profile_value, buf, 6);
@@ -2080,8 +2080,8 @@ static int esp_ssl_write_hello_verify_request(mbedtls_ssl_context *ssl)
 
     ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -2356,7 +2356,7 @@ static int esp_ssl_write_server_hello(mbedtls_ssl_context *ssl)
     ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
     ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
 
-    ret = mbedtls_ssl_write_handshake_msg(ssl);
+    ret = esp_mbedtls_ssl_write_handshake_msg(ssl);
 
     MBEDTLS_SSL_DEBUG_MSG(2, ("<= write server hello"));
 
@@ -2460,7 +2460,7 @@ static int esp_ssl_write_certificate_request(mbedtls_ssl_context *ssl)
      *     enum { (255) } HashAlgorithm;
      *     enum { (255) } SignatureAlgorithm;
      */
-    const uint16_t *sig_alg = mbedtls_ssl_get_sig_algs(ssl);
+    const uint16_t *sig_alg = esp_mbedtls_ssl_get_sig_algs(ssl);
     if (sig_alg == NULL) {
         return MBEDTLS_ERR_SSL_BAD_CONFIG;
     }
@@ -2471,7 +2471,7 @@ static int esp_ssl_write_certificate_request(mbedtls_ssl_context *ssl)
         if (esp_mbedtls_ssl_set_calc_verify_md(ssl, hash)) {
             continue;
         }
-        if (!mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
+        if (!esp_mbedtls_ssl_sig_alg_is_supported(ssl, *sig_alg)) {
             continue;
         }
 
@@ -2546,7 +2546,7 @@ static int esp_ssl_write_certificate_request(mbedtls_ssl_context *ssl)
     ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
     MBEDTLS_PUT_UINT16_BE(total_dn_size, ssl->out_msg, 4 + ct_len + sa_len);
 
-    ret = mbedtls_ssl_write_handshake_msg(ssl);
+    ret = esp_mbedtls_ssl_write_handshake_msg(ssl);
 
     MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate request"));
 
@@ -2571,7 +2571,7 @@ static int esp_ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
     mbedtls_pk_context *pk;
     mbedtls_ecp_keypair *key;
 
-    pk = mbedtls_ssl_own_key(ssl);
+    pk = esp_mbedtls_ssl_own_key(ssl);
 
     if (pk == NULL) {
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
@@ -2662,7 +2662,7 @@ static int esp_ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 
-    const mbedtls_pk_context *private_key = mbedtls_ssl_own_key(ssl);
+    const mbedtls_pk_context *private_key = esp_mbedtls_ssl_own_key(ssl);
     if (private_key == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("got no server private key"));
         return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
@@ -2674,7 +2674,7 @@ static int esp_ssl_get_ecdh_params_from_cert(mbedtls_ssl_context *ssl)
     }
 
     if ((ret = esp_mbedtls_ecdh_get_params(&ssl->handshake->ecdh_ctx,
-                                       mbedtls_pk_ec(*mbedtls_ssl_own_key(ssl)),
+                                       mbedtls_pk_ec(*esp_mbedtls_ssl_own_key(ssl)),
                                        MBEDTLS_ECDH_OURS)) != 0) {
         MBEDTLS_SSL_DEBUG_RET(1, ("esp_mbedtls_ecdh_get_params"), ret);
         return ret;
@@ -2889,7 +2889,7 @@ static int esp_ssl_prepare_server_key_exchange(mbedtls_ssl_context *ssl,
          * } ServerECDHParams;
          */
         uint16_t *curr_tls_id = ssl->handshake->curves_tls_id;
-        const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+        const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
         int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
         size_t len = 0;
 
@@ -3116,7 +3116,7 @@ curve_matching_done:
 #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
         if (ssl->conf->f_async_sign_start != NULL) {
             ret = ssl->conf->f_async_sign_start(ssl,
-                                                mbedtls_ssl_own_cert(ssl),
+                                                esp_mbedtls_ssl_own_cert(ssl),
                                                 md_alg, hash, hashlen);
             switch (ret) {
                 case MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH:
@@ -3135,7 +3135,7 @@ curve_matching_done:
         }
 #endif /* MBEDTLS_SSL_ASYNC_PRIVATE */
 
-        if (mbedtls_ssl_own_key(ssl) == NULL) {
+        if (esp_mbedtls_ssl_own_key(ssl) == NULL) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("got no private key"));
             return MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED;
         }
@@ -3145,7 +3145,7 @@ curve_matching_done:
          * after the call to esp_ssl_prepare_server_key_exchange.
          * esp_ssl_write_server_key_exchange also takes care of incrementing
          * ssl->out_msglen. */
-        if ((ret = esp_mbedtls_pk_sign(mbedtls_ssl_own_key(ssl),
+        if ((ret = esp_mbedtls_pk_sign(esp_mbedtls_ssl_own_key(ssl),
                                    md_alg, hash, hashlen,
                                    ssl->out_msg + ssl->out_msglen + 2,
                                    out_buf_len - ssl->out_msglen - 2,
@@ -3252,8 +3252,8 @@ static int esp_ssl_write_server_key_exchange(mbedtls_ssl_context *ssl)
 
     ssl->state++;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -3280,8 +3280,8 @@ static int esp_ssl_write_server_hello_done(mbedtls_ssl_context *ssl)
     }
 #endif
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
@@ -3368,13 +3368,13 @@ static int esp_ssl_decrypt_encrypted_pms(mbedtls_ssl_context *ssl,
 {
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
 
-    mbedtls_x509_crt *own_cert = mbedtls_ssl_own_cert(ssl);
+    mbedtls_x509_crt *own_cert = esp_mbedtls_ssl_own_cert(ssl);
     if (own_cert == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("got no local certificate"));
         return MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE;
     }
     mbedtls_pk_context *public_key = &own_cert->pk;
-    mbedtls_pk_context *private_key = mbedtls_ssl_own_key(ssl);
+    mbedtls_pk_context *private_key = esp_mbedtls_ssl_own_key(ssl);
     size_t len = mbedtls_pk_get_len(public_key);
 
 #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
@@ -3411,7 +3411,7 @@ static int esp_ssl_decrypt_encrypted_pms(mbedtls_ssl_context *ssl,
 #if defined(MBEDTLS_SSL_ASYNC_PRIVATE)
     if (ssl->conf->f_async_decrypt_start != NULL) {
         ret = ssl->conf->f_async_decrypt_start(ssl,
-                                               mbedtls_ssl_own_cert(ssl),
+                                               esp_mbedtls_ssl_own_cert(ssl),
                                                p, len);
         switch (ret) {
             case MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH:
@@ -3616,7 +3616,7 @@ static int esp_ssl_parse_client_key_exchange(mbedtls_ssl_context *ssl)
         return ret;
     }
 
-    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len(ssl);
+    p = ssl->in_msg + esp_mbedtls_ssl_hs_hdr_len(ssl);
     end = ssl->in_msg + ssl->in_hslen;
 
     if (ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE) {
@@ -4057,7 +4057,7 @@ static int esp_ssl_parse_certificate_verify(mbedtls_ssl_context *ssl)
         return MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE;
     }
 
-    i = mbedtls_ssl_hs_hdr_len(ssl);
+    i = esp_mbedtls_ssl_hs_hdr_len(ssl);
 
 #if !defined(MBEDTLS_SSL_KEEP_PEER_CERTIFICATE)
     peer_pk = &ssl->handshake->peer_pubkey;
@@ -4207,8 +4207,8 @@ static int esp_ssl_write_new_session_ticket(mbedtls_ssl_context *ssl)
      */
     ssl->handshake->new_session_ticket = 0;
 
-    if ((ret = mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
-        MBEDTLS_SSL_DEBUG_RET(1, "mbedtls_ssl_write_handshake_msg", ret);
+    if ((ret = esp_mbedtls_ssl_write_handshake_msg(ssl)) != 0) {
+        MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_write_handshake_msg", ret);
         return ret;
     }
 
diff --git a/library/ssl_tls13_client.c b/library/ssl_tls13_client.c
index a74c26b519524553137611b91ea21cc739c0b2c0..8d3c2efefe11459443f97c3428e0fa1177f163b5 100644
--- a/library/ssl_tls13_client.c
+++ b/library/ssl_tls13_client.c
@@ -93,7 +93,7 @@ static int esp_ssl_tls13_write_supported_versions_ext(mbedtls_ssl_context *ssl,
 
     *out_len = 5 + versions_len;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
         ssl, MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS);
 
     return 0;
@@ -185,7 +185,7 @@ static int esp_ssl_tls13_reset_key_share(mbedtls_ssl_context *ssl)
     }
 
 #if defined(MBEDTLS_ECDH_C)
-    if (mbedtls_ssl_tls13_named_group_is_ecdhe(group_id)) {
+    if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(group_id)) {
         int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
         psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
 
@@ -220,7 +220,7 @@ static int esp_ssl_tls13_get_default_group_id(mbedtls_ssl_context *ssl,
 
 
 #if defined(MBEDTLS_ECDH_C)
-    const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+    const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
     /* Pick first available ECDHE group compatible with TLS 1.3 */
     if (group_list == NULL) {
         return MBEDTLS_ERR_SSL_BAD_CONFIG;
@@ -229,7 +229,7 @@ static int esp_ssl_tls13_get_default_group_id(mbedtls_ssl_context *ssl,
     for (; *group_list != 0; group_list++) {
         if ((esp_mbedtls_ssl_get_psa_curve_info_from_tls_id(*group_list,
                                                         NULL, NULL) == PSA_SUCCESS) &&
-            mbedtls_ssl_tls13_named_group_is_ecdhe(*group_list)) {
+            esp_mbedtls_ssl_tls13_named_group_is_ecdhe(*group_list)) {
             *group_id = *group_list;
             return 0;
         }
@@ -286,8 +286,8 @@ static int esp_ssl_tls13_write_key_share_ext(mbedtls_ssl_context *ssl,
 
     /* HRR could already have requested something else. */
     group_id = ssl->handshake->offered_group_id;
-    if (!mbedtls_ssl_tls13_named_group_is_ecdhe(group_id) &&
-        !mbedtls_ssl_tls13_named_group_is_dhe(group_id)) {
+    if (!esp_mbedtls_ssl_tls13_named_group_is_ecdhe(group_id) &&
+        !esp_mbedtls_ssl_tls13_named_group_is_dhe(group_id)) {
         MBEDTLS_SSL_PROC_CHK(esp_ssl_tls13_get_default_group_id(ssl,
                                                             &group_id));
     }
@@ -302,7 +302,7 @@ static int esp_ssl_tls13_write_key_share_ext(mbedtls_ssl_context *ssl,
      */
     client_shares = p;
 #if defined(MBEDTLS_ECDH_C)
-    if (mbedtls_ssl_tls13_named_group_is_ecdhe(group_id)) {
+    if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(group_id)) {
         /* Pointer to group */
         unsigned char *group = p;
         /* Length of key_exchange */
@@ -354,7 +354,7 @@ static int esp_ssl_tls13_write_key_share_ext(mbedtls_ssl_context *ssl,
 
     MBEDTLS_SSL_DEBUG_BUF(3, "client hello, key_share extension", buf, *out_len);
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
 
 cleanup:
 
@@ -380,7 +380,7 @@ static int esp_ssl_tls13_parse_hrr_key_share_ext(mbedtls_ssl_context *ssl,
     int selected_group;
     int found = 0;
 
-    const uint16_t *group_list = mbedtls_ssl_get_groups(ssl);
+    const uint16_t *group_list = esp_mbedtls_ssl_get_groups(ssl);
     if (group_list == NULL) {
         return MBEDTLS_ERR_SSL_BAD_CONFIG;
     }
@@ -481,7 +481,7 @@ static int esp_ssl_tls13_parse_key_share_ext(mbedtls_ssl_context *ssl,
     }
 
 #if defined(MBEDTLS_ECDH_C)
-    if (mbedtls_ssl_tls13_named_group_is_ecdhe(group)) {
+    if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(group)) {
         if (esp_mbedtls_ssl_get_psa_curve_info_from_tls_id(group, NULL, NULL)
             == PSA_ERROR_NOT_SUPPORTED) {
             MBEDTLS_SSL_DEBUG_MSG(1, ("Invalid TLS curve group id"));
@@ -588,7 +588,7 @@ static int esp_ssl_tls13_write_cookie_ext(mbedtls_ssl_context *ssl,
 
     *out_len = handshake->cookie_len + 6;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_COOKIE);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_COOKIE);
 
     return 0;
 }
@@ -618,7 +618,7 @@ static int esp_ssl_tls13_write_psk_key_exchange_modes_ext(mbedtls_ssl_context *s
     /* Skip writing extension if no PSK key exchange mode
      * is enabled in the config.
      */
-    if (!mbedtls_ssl_conf_tls13_some_psk_enabled(ssl)) {
+    if (!esp_mbedtls_ssl_conf_tls13_some_psk_enabled(ssl)) {
         MBEDTLS_SSL_DEBUG_MSG(3, ("skip psk_key_exchange_modes extension"));
         return 0;
     }
@@ -637,14 +637,14 @@ static int esp_ssl_tls13_write_psk_key_exchange_modes_ext(mbedtls_ssl_context *s
      */
     p += 5;
 
-    if (mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(ssl)) {
+    if (esp_mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(ssl)) {
         *p++ = MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE;
         ke_modes_len++;
 
         MBEDTLS_SSL_DEBUG_MSG(4, ("Adding PSK-ECDHE key exchange mode"));
     }
 
-    if (mbedtls_ssl_conf_tls13_psk_enabled(ssl)) {
+    if (esp_mbedtls_ssl_conf_tls13_psk_enabled(ssl)) {
         *p++ = MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE;
         ke_modes_len++;
 
@@ -657,7 +657,7 @@ static int esp_ssl_tls13_write_psk_key_exchange_modes_ext(mbedtls_ssl_context *s
 
     *out_len = p - buf;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
         ssl, MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES);
 
     return 0;
@@ -681,8 +681,8 @@ static int esp_ssl_tls13_has_configured_ticket(mbedtls_ssl_context *ssl)
     mbedtls_ssl_session *session = ssl->session_negotiate;
     return ssl->handshake->resume &&
            session != NULL && session->ticket != NULL &&
-           mbedtls_ssl_conf_tls13_check_kex_modes(
-        ssl, mbedtls_ssl_session_get_ticket_flags(
+           esp_mbedtls_ssl_conf_tls13_check_kex_modes(
+        ssl, esp_mbedtls_ssl_session_get_ticket_flags(
             session, MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL));
 }
 
@@ -694,7 +694,7 @@ static int esp_ssl_tls13_early_data_has_valid_ticket(mbedtls_ssl_context *ssl)
            session->tls_version == MBEDTLS_SSL_VERSION_TLS1_3 &&
            (session->ticket_flags &
             MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_EARLY_DATA) &&
-           mbedtls_ssl_tls13_cipher_suite_is_offered(
+           esp_mbedtls_ssl_tls13_cipher_suite_is_offered(
         ssl, session->ciphersuite);
 }
 #endif
@@ -1059,7 +1059,7 @@ int esp_mbedtls_ssl_tls13_write_binders_of_pre_shared_key_ext(
 
     MBEDTLS_SSL_DEBUG_BUF(3, "pre_shared_key binders", buf, p - buf);
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
         ssl, MBEDTLS_TLS_EXT_PRE_SHARED_KEY);
 
     return 0;
@@ -1174,7 +1174,7 @@ int esp_mbedtls_ssl_tls13_write_client_hello_exts(mbedtls_ssl_context *ssl,
     p += ext_len;
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_EPHEMERAL_ENABLED)
-    if (mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
+    if (esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
         ret = esp_ssl_tls13_write_key_share_ext(ssl, p, end, &ext_len);
         if (ret != 0) {
             return ret;
@@ -1184,7 +1184,7 @@ int esp_mbedtls_ssl_tls13_write_client_hello_exts(mbedtls_ssl_context *ssl,
 #endif
 
 #if defined(MBEDTLS_SSL_EARLY_DATA)
-    if (mbedtls_ssl_conf_tls13_some_psk_enabled(ssl) &&
+    if (esp_mbedtls_ssl_conf_tls13_some_psk_enabled(ssl) &&
         esp_ssl_tls13_early_data_has_valid_ticket(ssl) &&
         ssl->conf->early_data_enabled == MBEDTLS_SSL_EARLY_DATA_ENABLED) {
         ret = esp_mbedtls_ssl_tls13_write_early_data_ext(ssl, p, end, &ext_len);
@@ -1239,7 +1239,7 @@ int esp_mbedtls_ssl_tls13_finalize_client_hello(mbedtls_ssl_context *ssl)
 
     if (ssl->early_data_status == MBEDTLS_SSL_EARLY_DATA_STATUS_REJECTED) {
 #if defined(MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE)
-        mbedtls_ssl_handshake_set_state(
+        esp_mbedtls_ssl_handshake_set_state(
             ssl, MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO);
 #endif
         MBEDTLS_SSL_DEBUG_MSG(
@@ -1497,7 +1497,7 @@ static int esp_ssl_tls13_preprocess_server_hello(mbedtls_ssl_context *ssl,
                                                                 MBEDTLS_SSL_HS_SERVER_HELLO,
                                                                 buf, (size_t) (end - buf)));
 
-        if (mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
+        if (esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
             ret = esp_ssl_tls13_reset_key_share(ssl);
             if (ret != 0) {
                 return ret;
@@ -1538,7 +1538,7 @@ static int esp_ssl_tls13_preprocess_server_hello(mbedtls_ssl_context *ssl,
              * in the ClientHello.
              * In a PSK only key exchange that what we expect.
              */
-            if (!mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
+            if (!esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
                 MBEDTLS_SSL_DEBUG_MSG(1,
                                       ("Unexpected HRR in pure PSK key exchange."));
                 MBEDTLS_SSL_PEND_FATAL_ALERT(
@@ -1693,7 +1693,7 @@ static int esp_ssl_tls13_parse_server_hello(mbedtls_ssl_context *ssl,
     if ((esp_mbedtls_ssl_validate_ciphersuite(ssl, ciphersuite_info,
                                           ssl->tls_version,
                                           ssl->tls_version) != 0) ||
-        !mbedtls_ssl_tls13_cipher_suite_is_offered(ssl, cipher_suite)) {
+        !esp_mbedtls_ssl_tls13_cipher_suite_is_offered(ssl, cipher_suite)) {
         fatal_alert = MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER;
     }
     /*
@@ -1815,7 +1815,7 @@ static int esp_ssl_tls13_parse_server_hello(mbedtls_ssl_context *ssl,
 
             case MBEDTLS_TLS_EXT_KEY_SHARE:
                 MBEDTLS_SSL_DEBUG_MSG(3, ("found key_shares extension"));
-                if (!mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
+                if (!esp_mbedtls_ssl_conf_tls13_some_ephemeral_enabled(ssl)) {
                     fatal_alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT;
                     goto cleanup;
                 }
@@ -1943,7 +1943,7 @@ static int esp_ssl_tls13_postprocess_server_hello(mbedtls_ssl_context *ssl)
     }
 #endif
 
-    if (!mbedtls_ssl_conf_tls13_check_kex_modes(
+    if (!esp_mbedtls_ssl_conf_tls13_check_kex_modes(
             ssl, handshake->key_exchange_mode)) {
         ret = MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE;
         MBEDTLS_SSL_DEBUG_MSG(2,
@@ -2072,14 +2072,14 @@ static int esp_ssl_tls13_process_server_hello(mbedtls_ssl_context *ssl)
          * immediately before its second flight. This may either be before
          * its second ClientHello or before its encrypted handshake flight.
          */
-        mbedtls_ssl_handshake_set_state(ssl,
+        esp_mbedtls_ssl_handshake_set_state(ssl,
                                         MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO);
 #else
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
 #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
     } else {
         MBEDTLS_SSL_PROC_CHK(esp_ssl_tls13_postprocess_server_hello(ssl));
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
     }
 
 cleanup:
@@ -2239,14 +2239,14 @@ static int esp_ssl_tls13_process_encrypted_extensions(mbedtls_ssl_context *ssl)
                                                             buf, buf_len));
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED)
-    if (mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    if (esp_mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
     } else {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_REQUEST);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_REQUEST);
     }
 #else
     ((void) ssl);
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
 #endif
 
 cleanup:
@@ -2286,7 +2286,7 @@ static int esp_ssl_tls13_write_end_of_early_data(mbedtls_ssl_context *ssl)
     MBEDTLS_SSL_PROC_CHK(
         esp_mbedtls_ssl_finish_handshake_msg(ssl, buf_len, 0));
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
 
 cleanup:
 
@@ -2490,7 +2490,7 @@ static int esp_ssl_tls13_process_certificate_request(mbedtls_ssl_context *ssl)
         goto cleanup;
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_CERTIFICATE);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_CERTIFICATE);
 
 cleanup:
 
@@ -2511,7 +2511,7 @@ static int esp_ssl_tls13_process_server_certificate(mbedtls_ssl_context *ssl)
         return ret;
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_VERIFY);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_VERIFY);
     return 0;
 }
 
@@ -2528,7 +2528,7 @@ static int esp_ssl_tls13_process_certificate_verify(mbedtls_ssl_context *ssl)
         return ret;
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
     return 0;
 }
 #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED */
@@ -2556,17 +2556,17 @@ static int esp_ssl_tls13_process_server_finished(mbedtls_ssl_context *ssl)
 
 #if defined(MBEDTLS_SSL_EARLY_DATA)
     if (ssl->early_data_status == MBEDTLS_SSL_EARLY_DATA_STATUS_ACCEPTED) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_END_OF_EARLY_DATA);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_END_OF_EARLY_DATA);
     } else if (ssl->early_data_status == MBEDTLS_SSL_EARLY_DATA_STATUS_REJECTED) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
     } else
 #endif /* MBEDTLS_SSL_EARLY_DATA */
     {
 #if defined(MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE)
-        mbedtls_ssl_handshake_set_state(
+        esp_mbedtls_ssl_handshake_set_state(
             ssl, MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED);
 #else
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
 #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
     }
 
@@ -2592,7 +2592,7 @@ static int esp_ssl_tls13_write_client_certificate(mbedtls_ssl_context *ssl)
             return ret;
         }
 
-        if (mbedtls_ssl_own_cert(ssl) != NULL) {
+        if (esp_mbedtls_ssl_own_cert(ssl) != NULL) {
             non_empty_certificate_msg = 1;
         }
     } else {
@@ -2601,11 +2601,11 @@ static int esp_ssl_tls13_write_client_certificate(mbedtls_ssl_context *ssl)
 #endif
 
     if (non_empty_certificate_msg) {
-        mbedtls_ssl_handshake_set_state(ssl,
+        esp_mbedtls_ssl_handshake_set_state(ssl,
                                         MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY);
     } else {
         MBEDTLS_SSL_DEBUG_MSG(2, ("skip write certificate verify"));
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
     }
 
     return 0;
@@ -2621,7 +2621,7 @@ static int esp_ssl_tls13_write_client_certificate_verify(mbedtls_ssl_context *ss
     int ret = esp_mbedtls_ssl_tls13_write_certificate_verify(ssl);
 
     if (ret == 0) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
     }
 
     return ret;
@@ -2648,7 +2648,7 @@ static int esp_ssl_tls13_write_client_finished(mbedtls_ssl_context *ssl)
         return ret;
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_FLUSH_BUFFERS);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_FLUSH_BUFFERS);
     return 0;
 }
 
@@ -2659,7 +2659,7 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_tls13_flush_buffers(mbedtls_ssl_context *ssl)
 {
     MBEDTLS_SSL_DEBUG_MSG(2, ("handshake: done"));
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_WRAPUP);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_WRAPUP);
     return 0;
 }
 
@@ -2672,7 +2672,7 @@ static int esp_ssl_tls13_handshake_wrapup(mbedtls_ssl_context *ssl)
 
     esp_mbedtls_ssl_tls13_handshake_wrapup(ssl);
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
     return 0;
 }
 
@@ -2817,7 +2817,7 @@ static int esp_ssl_tls13_parse_new_session_ticket(mbedtls_ssl_context *ssl,
     session->ticket_len = ticket_len;
 
     /* Clear all flags in ticket_flags */
-    mbedtls_ssl_session_clear_ticket_flags(
+    esp_mbedtls_ssl_session_clear_ticket_flags(
         session, MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK);
 
     MBEDTLS_SSL_CHK_BUF_READ_PTR(p, end, 2);
@@ -2904,7 +2904,7 @@ static int esp_ssl_tls13_postprocess_new_session_ticket(mbedtls_ssl_context *ssl
                           session->resumption_key_len);
 
     /* Set ticket_flags depends on the selected key exchange modes */
-    mbedtls_ssl_session_set_ticket_flags(
+    esp_mbedtls_ssl_session_set_ticket_flags(
         session, ssl->conf->tls13_kex_modes);
     MBEDTLS_SSL_PRINT_TICKET_FLAGS(4, session->ticket_flags);
 
@@ -2936,7 +2936,7 @@ static int esp_ssl_tls13_process_new_session_ticket(mbedtls_ssl_context *ssl)
     MBEDTLS_SSL_PROC_CHK(esp_ssl_tls13_postprocess_new_session_ticket(
                              ssl, ticket_nonce, ticket_nonce_len));
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
 
 cleanup:
 
@@ -2951,7 +2951,7 @@ int esp_mbedtls_ssl_tls13_handshake_client_step(mbedtls_ssl_context *ssl)
 
     switch (ssl->state) {
         case MBEDTLS_SSL_HELLO_REQUEST:
-            mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+            esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
             break;
 
         case MBEDTLS_SSL_CLIENT_HELLO:
@@ -3017,21 +3017,21 @@ int esp_mbedtls_ssl_tls13_handshake_client_step(mbedtls_ssl_context *ssl)
         case MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO:
             ret = esp_mbedtls_ssl_tls13_write_change_cipher_spec(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
             }
             break;
 
         case MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED:
             ret = esp_mbedtls_ssl_tls13_write_change_cipher_spec(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
             }
             break;
 
         case MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO:
             ret = esp_mbedtls_ssl_tls13_write_change_cipher_spec(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
 
 #if defined(MBEDTLS_SSL_EARLY_DATA)
                 MBEDTLS_SSL_DEBUG_MSG(
diff --git a/library/ssl_tls13_generic.c b/library/ssl_tls13_generic.c
index ccf168ff1f6ec71be32bc6398a053c7fe88d53d5..a8d3dbb8dcf97725d5436b1c808adcf23b60e586 100644
--- a/library/ssl_tls13_generic.c
+++ b/library/ssl_tls13_generic.c
@@ -204,7 +204,7 @@ static int esp_ssl_tls13_parse_certificate_verify(mbedtls_ssl_context *ssl,
      *
      * Check if algorithm is an offered signature algorithm.
      */
-    if (!mbedtls_ssl_sig_alg_is_offered(ssl, algorithm)) {
+    if (!esp_mbedtls_ssl_sig_alg_is_offered(ssl, algorithm)) {
         /* algorithm not in offered signature algorithms list */
         MBEDTLS_SSL_DEBUG_MSG(1, ("Received signature algorithm(%04x) is not "
                                   "offered.",
@@ -212,7 +212,7 @@ static int esp_ssl_tls13_parse_certificate_verify(mbedtls_ssl_context *ssl,
         goto error;
     }
 
-    if (mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
+    if (esp_mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
             algorithm, &sig_alg, &md_alg) != 0) {
         goto error;
     }
@@ -801,7 +801,7 @@ static int esp_ssl_tls13_write_certificate_body(mbedtls_ssl_context *ssl,
                                             unsigned char *end,
                                             size_t *out_len)
 {
-    const mbedtls_x509_crt *crt = mbedtls_ssl_own_cert(ssl);
+    const mbedtls_x509_crt *crt = esp_mbedtls_ssl_own_cert(ssl);
     unsigned char *p = buf;
     unsigned char *certificate_request_context =
         ssl->handshake->certificate_request_context;
@@ -956,7 +956,7 @@ static int esp_ssl_tls13_write_certificate_verify_body(mbedtls_ssl_context *ssl,
 
     *out_len = 0;
 
-    own_key = mbedtls_ssl_own_key(ssl);
+    own_key = esp_mbedtls_ssl_own_key(ssl);
     if (own_key == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(1, ("should never happen"));
         return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
@@ -998,11 +998,11 @@ static int esp_ssl_tls13_write_certificate_verify_body(mbedtls_ssl_context *ssl,
         unsigned char verify_hash[PSA_HASH_MAX_SIZE];
         size_t verify_hash_len;
 
-        if (!mbedtls_ssl_sig_alg_is_offered(ssl, *sig_alg)) {
+        if (!esp_mbedtls_ssl_sig_alg_is_offered(ssl, *sig_alg)) {
             continue;
         }
 
-        if (!mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(*sig_alg)) {
+        if (!esp_mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(*sig_alg)) {
             continue;
         }
 
@@ -1010,7 +1010,7 @@ static int esp_ssl_tls13_write_certificate_verify_body(mbedtls_ssl_context *ssl,
             continue;
         }
 
-        if (mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
+        if (esp_mbedtls_ssl_get_pk_type_and_md_alg_from_sig_alg(
                 *sig_alg, &pk_type, &md_alg) != 0) {
             return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
         }
@@ -1367,7 +1367,7 @@ int esp_mbedtls_ssl_tls13_write_early_data_ext(mbedtls_ssl_context *ssl,
 
     *out_len = 4;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_EARLY_DATA);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_EARLY_DATA);
 
     return 0;
 }
diff --git a/library/ssl_tls13_keys.c b/library/ssl_tls13_keys.c
index de071bad77bc1fb75ad4726305647ca3a0ba523b..87b9eadca0587347b15afa8b11d5e8361315f6b3 100644
--- a/library/ssl_tls13_keys.c
+++ b/library/ssl_tls13_keys.c
@@ -1276,7 +1276,7 @@ int esp_mbedtls_ssl_tls13_key_schedule_stage_early(mbedtls_ssl_context *ssl)
 
     hash_alg = esp_mbedtls_hash_info_psa_from_md(handshake->ciphersuite_info->mac);
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED)
-    if (mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
+    if (esp_mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
         ret = esp_mbedtls_ssl_tls13_export_handshake_psk(ssl, &psk, &psk_len);
         if (ret != 0) {
             MBEDTLS_SSL_DEBUG_RET(1, "esp_mbedtls_ssl_tls13_export_handshake_psk",
@@ -1461,8 +1461,8 @@ static int esp_ssl_tls13_key_schedule_stage_handshake(mbedtls_ssl_context *ssl)
      * client_handshake_traffic_secret and server_handshake_traffic_secret
      * are derived in the handshake secret derivation stage.
      */
-    if (mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
-        if (mbedtls_ssl_tls13_named_group_is_ecdhe(handshake->offered_group_id)) {
+    if (esp_mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
+        if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(handshake->offered_group_id)) {
 #if defined(MBEDTLS_ECDH_C)
             /* Compute ECDH shared secret. */
             psa_status_t status = PSA_ERROR_GENERIC_ERROR;
diff --git a/library/ssl_tls13_server.c b/library/ssl_tls13_server.c
index 5a0b7dafb4aec777eed3c1c5b94d94daff54830a..87bf17b9e7fcf74736e61183a8b42509a0b819b0 100644
--- a/library/ssl_tls13_server.c
+++ b/library/ssl_tls13_server.c
@@ -36,7 +36,7 @@ static const mbedtls_ssl_ciphersuite_t *esp_ssl_tls13_validate_peer_ciphersuite(
     unsigned int cipher_suite)
 {
     const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
-    if (!mbedtls_ssl_tls13_cipher_suite_is_offered(ssl, cipher_suite)) {
+    if (!esp_mbedtls_ssl_tls13_cipher_suite_is_offered(ssl, cipher_suite)) {
         return NULL;
     }
 
@@ -172,9 +172,9 @@ static int esp_ssl_tls13_offered_psks_check_identity_match_ticket(
     ret = MBEDTLS_ERR_ERROR_GENERIC_ERROR;
     MBEDTLS_SSL_PRINT_TICKET_FLAGS(4,
                                    session->ticket_flags);
-    if (mbedtls_ssl_tls13_check_kex_modes(
+    if (esp_mbedtls_ssl_tls13_check_kex_modes(
             ssl,
-            mbedtls_ssl_session_get_ticket_flags(
+            esp_mbedtls_ssl_session_get_ticket_flags(
                 session,
                 MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL))) {
         MBEDTLS_SSL_DEBUG_MSG(3, ("No suitable key exchange mode"));
@@ -717,7 +717,7 @@ static int esp_ssl_tls13_write_server_pre_shared_key_ext(mbedtls_ssl_context *ss
     MBEDTLS_SSL_DEBUG_MSG(4, ("sent selected_identity: %u",
                               ssl->handshake->selected_identity));
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_PRE_SHARED_KEY);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_PRE_SHARED_KEY);
 
     return 0;
 }
@@ -811,8 +811,8 @@ static int esp_ssl_tls13_parse_supported_groups_ext(mbedtls_ssl_context *ssl,
                                esp_mbedtls_ssl_named_group_to_str(named_group),
                                named_group));
 
-        if (!mbedtls_ssl_named_group_is_offered(ssl, named_group) ||
-            !mbedtls_ssl_named_group_is_supported(named_group) ||
+        if (!esp_mbedtls_ssl_named_group_is_offered(ssl, named_group) ||
+            !esp_mbedtls_ssl_named_group_is_supported(named_group) ||
             ssl->handshake->hrr_selected_group != 0) {
             continue;
         }
@@ -898,8 +898,8 @@ static int esp_ssl_tls13_parse_key_shares_ext(mbedtls_ssl_context *ssl,
         /* Continue parsing even if we have already found a match,
          * for input validation purposes.
          */
-        if (!mbedtls_ssl_named_group_is_offered(ssl, group) ||
-            !mbedtls_ssl_named_group_is_supported(group) ||
+        if (!esp_mbedtls_ssl_named_group_is_offered(ssl, group) ||
+            !esp_mbedtls_ssl_named_group_is_supported(group) ||
             ssl->handshake->offered_group_id != 0) {
             continue;
         }
@@ -907,7 +907,7 @@ static int esp_ssl_tls13_parse_key_shares_ext(mbedtls_ssl_context *ssl,
         /*
          * For now, we only support ECDHE groups.
          */
-        if (mbedtls_ssl_tls13_named_group_is_ecdhe(group)) {
+        if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(group)) {
             MBEDTLS_SSL_DEBUG_MSG(2, ("ECDH group: %s (%04x)",
                                       esp_mbedtls_ssl_named_group_to_str(group),
                                       group));
@@ -986,7 +986,7 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_tls13_check_ephemeral_key_exchange(mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED)
-    return mbedtls_ssl_conf_tls13_ephemeral_enabled(ssl) &&
+    return esp_mbedtls_ssl_conf_tls13_ephemeral_enabled(ssl) &&
            esp_ssl_tls13_client_hello_has_exts_for_ephemeral_key_exchange(ssl);
 #else
     ((void) ssl);
@@ -998,8 +998,8 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_tls13_check_psk_key_exchange(mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ENABLED)
-    return mbedtls_ssl_conf_tls13_psk_enabled(ssl) &&
-           mbedtls_ssl_tls13_psk_enabled(ssl) &&
+    return esp_mbedtls_ssl_conf_tls13_psk_enabled(ssl) &&
+           esp_mbedtls_ssl_tls13_psk_enabled(ssl) &&
            esp_ssl_tls13_client_hello_has_exts_for_psk_key_exchange(ssl);
 #else
     ((void) ssl);
@@ -1011,8 +1011,8 @@ MBEDTLS_CHECK_RETURN_CRITICAL
 static int esp_ssl_tls13_check_psk_ephemeral_key_exchange(mbedtls_ssl_context *ssl)
 {
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL_ENABLED)
-    return mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(ssl) &&
-           mbedtls_ssl_tls13_psk_ephemeral_enabled(ssl) &&
+    return esp_mbedtls_ssl_conf_tls13_psk_ephemeral_enabled(ssl) &&
+           esp_mbedtls_ssl_tls13_psk_ephemeral_enabled(ssl) &&
            esp_ssl_tls13_client_hello_has_exts_for_psk_ephemeral_key_exchange(ssl);
 #else
     ((void) ssl);
@@ -1120,11 +1120,11 @@ static int esp_ssl_tls13_pick_key_cert(mbedtls_ssl_context *ssl)
     }
 
     for (; *sig_alg != MBEDTLS_TLS1_3_SIG_NONE; sig_alg++) {
-        if (!mbedtls_ssl_sig_alg_is_offered(ssl, *sig_alg)) {
+        if (!esp_mbedtls_ssl_sig_alg_is_offered(ssl, *sig_alg)) {
             continue;
         }
 
-        if (!mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(*sig_alg)) {
+        if (!esp_mbedtls_ssl_tls13_sig_alg_for_cert_verify_is_supported(*sig_alg)) {
             continue;
         }
 
@@ -1649,8 +1649,8 @@ static int esp_ssl_tls13_parse_client_hello(mbedtls_ssl_context *ssl,
      * - The content up to but excluding the PSK extension, if present.
      */
     /* If we've settled on a PSK-based exchange, parse PSK identity ext */
-    if (mbedtls_ssl_tls13_some_psk_enabled(ssl) &&
-        mbedtls_ssl_conf_tls13_some_psk_enabled(ssl) &&
+    if (esp_mbedtls_ssl_tls13_some_psk_enabled(ssl) &&
+        esp_mbedtls_ssl_conf_tls13_some_psk_enabled(ssl) &&
         (handshake->received_extensions & MBEDTLS_SSL_EXT_MASK(PRE_SHARED_KEY))) {
         ret = handshake->update_checksum(ssl, buf,
                                          pre_shared_key_ext - buf);
@@ -1750,9 +1750,9 @@ static int esp_ssl_tls13_process_client_hello(mbedtls_ssl_context *ssl)
     MBEDTLS_SSL_PROC_CHK(esp_ssl_tls13_postprocess_client_hello(ssl));
 
     if (parse_client_hello_ret == SSL_CLIENT_HELLO_OK) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_HELLO);
     } else {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HELLO_RETRY_REQUEST);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HELLO_RETRY_REQUEST);
     }
 
 cleanup:
@@ -1829,7 +1829,7 @@ static int esp_ssl_tls13_write_server_hello_supported_versions_ext(
 
     *out_len = 6;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(
         ssl, MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS);
 
     return 0;
@@ -1851,7 +1851,7 @@ static int esp_ssl_tls13_generate_and_write_key_share(mbedtls_ssl_context *ssl,
     *out_len = 0;
 
 #if defined(MBEDTLS_ECDH_C)
-    if (mbedtls_ssl_tls13_named_group_is_ecdhe(named_group)) {
+    if (esp_mbedtls_ssl_tls13_named_group_is_ecdhe(named_group)) {
         ret = esp_mbedtls_ssl_tls13_generate_and_write_ecdh_key_exchange(
             ssl, named_group, buf, end, out_len);
         if (ret != 0) {
@@ -1933,7 +1933,7 @@ static int esp_ssl_tls13_write_key_share_ext(mbedtls_ssl_context *ssl,
 
     *out_len = p - buf;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
 
     return 0;
 }
@@ -1964,7 +1964,7 @@ static int esp_ssl_tls13_write_hrr_key_share_ext(mbedtls_ssl_context *ssl,
      * of the HRR is then to transmit a cookie to force the client to demonstrate
      * reachability at their apparent network address (primarily useful for DTLS).
      */
-    if (!mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
+    if (!esp_mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
         return 0;
     }
 
@@ -1998,7 +1998,7 @@ static int esp_ssl_tls13_write_hrr_key_share_ext(mbedtls_ssl_context *ssl,
 
     *out_len = 6;
 
-    mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
+    esp_mbedtls_ssl_tls13_set_hs_sent_ext_mask(ssl, MBEDTLS_TLS_EXT_KEY_SHARE);
 
     return 0;
 }
@@ -2115,7 +2115,7 @@ static int esp_ssl_tls13_write_server_hello_body(mbedtls_ssl_context *ssl,
     }
     p += output_len;
 
-    if (mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
+    if (esp_mbedtls_ssl_tls13_key_exchange_mode_with_ephemeral(ssl)) {
         if (is_hrr) {
             ret = esp_ssl_tls13_write_hrr_key_share_ext(ssl, p, end, &output_len);
         } else {
@@ -2128,7 +2128,7 @@ static int esp_ssl_tls13_write_server_hello_body(mbedtls_ssl_context *ssl,
     }
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED)
-    if (!is_hrr && mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
+    if (!is_hrr && esp_mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
         ret = esp_ssl_tls13_write_server_pre_shared_key_ext(ssl, p, end, &output_len);
         if (ret != 0) {
             MBEDTLS_SSL_DEBUG_RET(1, "esp_ssl_tls13_write_server_pre_shared_key_ext",
@@ -2204,10 +2204,10 @@ static int esp_ssl_tls13_write_server_hello(mbedtls_ssl_context *ssl)
      * after its first handshake message. This may either be after
      * a ServerHello or a HelloRetryRequest.
      */
-    mbedtls_ssl_handshake_set_state(
+    esp_mbedtls_ssl_handshake_set_state(
         ssl, MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO);
 #else
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
 #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
 
 cleanup:
@@ -2278,10 +2278,10 @@ static int esp_ssl_tls13_write_hello_retry_request(mbedtls_ssl_context *ssl)
      * after its first handshake message. This may either be after
      * a ServerHello or a HelloRetryRequest.
      */
-    mbedtls_ssl_handshake_set_state(
+    esp_mbedtls_ssl_handshake_set_state(
         ssl, MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST);
 #else
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
 #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
 
 cleanup:
@@ -2370,13 +2370,13 @@ static int esp_ssl_tls13_write_encrypted_extensions(mbedtls_ssl_context *ssl)
                              ssl, buf_len, msg_len));
 
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED)
-    if (mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    if (esp_mbedtls_ssl_tls13_key_exchange_mode_with_psk(ssl)) {
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
     } else {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_REQUEST);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_REQUEST);
     }
 #else
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
 #endif
 
 cleanup:
@@ -2510,7 +2510,7 @@ static int esp_ssl_tls13_write_certificate_request(mbedtls_ssl_context *ssl)
         goto cleanup;
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_CERTIFICATE);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_CERTIFICATE);
 cleanup:
 
     MBEDTLS_SSL_DEBUG_MSG(2, ("<= write certificate request"));
@@ -2527,7 +2527,7 @@ static int esp_ssl_tls13_write_server_certificate(mbedtls_ssl_context *ssl)
 
 #if defined(MBEDTLS_X509_CRT_PARSE_C)
     if ((esp_ssl_tls13_pick_key_cert(ssl) != 0) ||
-        mbedtls_ssl_own_cert(ssl) == NULL) {
+        esp_mbedtls_ssl_own_cert(ssl) == NULL) {
         MBEDTLS_SSL_DEBUG_MSG(2, ("No certificate available."));
         MBEDTLS_SSL_PEND_FATAL_ALERT(MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE,
                                      MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE);
@@ -2539,7 +2539,7 @@ static int esp_ssl_tls13_write_server_certificate(mbedtls_ssl_context *ssl)
     if (ret != 0) {
         return ret;
     }
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_VERIFY);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CERTIFICATE_VERIFY);
     return 0;
 }
 
@@ -2553,7 +2553,7 @@ static int esp_ssl_tls13_write_certificate_verify(mbedtls_ssl_context *ssl)
     if (ret != 0) {
         return ret;
     }
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_SERVER_FINISHED);
     return 0;
 }
 #endif /* MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ENABLED */
@@ -2583,11 +2583,11 @@ static int esp_ssl_tls13_write_server_finished(mbedtls_ssl_context *ssl)
     esp_mbedtls_ssl_set_inbound_transform(ssl, ssl->handshake->transform_handshake);
 
     if (ssl->handshake->certificate_request_sent) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE);
     } else {
         MBEDTLS_SSL_DEBUG_MSG(2, ("skip parse certificate"));
         MBEDTLS_SSL_DEBUG_MSG(2, ("skip parse certificate verify"));
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_FINISHED);
     }
 
     return 0;
@@ -2612,7 +2612,7 @@ static int esp_ssl_tls13_process_client_finished(mbedtls_ssl_context *ssl)
                               "esp_mbedtls_ssl_tls13_compute_resumption_master_secret", ret);
     }
 
-    mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_WRAPUP);
+    esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_WRAPUP);
     return 0;
 }
 
@@ -2633,12 +2633,12 @@ static int esp_ssl_tls13_handshake_wrapup(mbedtls_ssl_context *ssl)
  *       expected to be resolved with issue#6395.
  */
     /* Sent NewSessionTicket message only when client supports PSK */
-    if (mbedtls_ssl_tls13_some_psk_enabled(ssl)) {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
+    if (esp_mbedtls_ssl_tls13_some_psk_enabled(ssl)) {
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
     } else
 #endif
     {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
     }
     return 0;
 }
@@ -2691,10 +2691,10 @@ static int esp_ssl_tls13_prepare_new_session_ticket(mbedtls_ssl_context *ssl,
 #endif
 
     /* Set ticket_flags depends on the advertised psk key exchange mode */
-    mbedtls_ssl_session_clear_ticket_flags(
+    esp_mbedtls_ssl_session_clear_ticket_flags(
         session, MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK);
 #if defined(MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_SOME_PSK_ENABLED)
-    mbedtls_ssl_session_set_ticket_flags(
+    esp_mbedtls_ssl_session_set_ticket_flags(
         session, ssl->handshake->tls13_kex_modes);
 #endif
     MBEDTLS_SSL_PRINT_TICKET_FLAGS(4, session->ticket_flags);
@@ -2918,10 +2918,10 @@ static int esp_ssl_tls13_write_new_session_ticket(mbedtls_ssl_context *ssl)
             ssl->handshake->new_session_tickets_count--;
         }
 
-        mbedtls_ssl_handshake_set_state(
+        esp_mbedtls_ssl_handshake_set_state(
             ssl, MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH);
     } else {
-        mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
+        esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
     }
 
 cleanup:
@@ -2948,7 +2948,7 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl)
     switch (ssl->state) {
         /* start state */
         case MBEDTLS_SSL_HELLO_REQUEST:
-            mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+            esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
             ret = 0;
             break;
 
@@ -3000,14 +3000,14 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl)
         case MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST:
             ret = esp_mbedtls_ssl_tls13_write_change_cipher_spec(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_CLIENT_HELLO);
             }
             break;
 
         case MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO:
             ret = esp_mbedtls_ssl_tls13_write_change_cipher_spec(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_ENCRYPTED_EXTENSIONS);
             }
             break;
 #endif /* MBEDTLS_SSL_TLS1_3_COMPATIBILITY_MODE */
@@ -3029,11 +3029,11 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl)
             ret = esp_mbedtls_ssl_tls13_process_certificate(ssl);
             if (ret == 0) {
                 if (ssl->session_negotiate->peer_cert != NULL) {
-                    mbedtls_ssl_handshake_set_state(
+                    esp_mbedtls_ssl_handshake_set_state(
                         ssl, MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY);
                 } else {
                     MBEDTLS_SSL_DEBUG_MSG(2, ("skip parse certificate verify"));
-                    mbedtls_ssl_handshake_set_state(
+                    esp_mbedtls_ssl_handshake_set_state(
                         ssl, MBEDTLS_SSL_CLIENT_FINISHED);
                 }
             }
@@ -3042,7 +3042,7 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl)
         case MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY:
             ret = esp_mbedtls_ssl_tls13_process_certificate_verify(ssl);
             if (ret == 0) {
-                mbedtls_ssl_handshake_set_state(
+                esp_mbedtls_ssl_handshake_set_state(
                     ssl, MBEDTLS_SSL_CLIENT_FINISHED);
             }
             break;
@@ -3065,9 +3065,9 @@ int esp_mbedtls_ssl_tls13_handshake_server_step(mbedtls_ssl_context *ssl)
             ret = 0;
 
             if (ssl->handshake->new_session_tickets_count == 0) {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_HANDSHAKE_OVER);
             } else {
-                mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
+                esp_mbedtls_ssl_handshake_set_state(ssl, MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET);
             }
             break;
 
diff --git a/tests/src/drivers/test_driver_aead.c b/tests/src/drivers/test_driver_aead.c
index 814eda9f85b3ba7b0012ad4384ae444094e49886..67efa5cc89b2874f029cce1f6814beaf4e624aaf 100644
--- a/tests/src/drivers/test_driver_aead.c
+++ b/tests/src/drivers/test_driver_aead.c
@@ -431,7 +431,7 @@ psa_status_t mbedtls_test_transparent_aead_verify(
 
         if (mbedtls_test_driver_aead_hooks.driver_status == PSA_SUCCESS) {
             if (tag_length != check_tag_length ||
-                mbedtls_psa_safer_memcmp(tag, check_tag, tag_length)
+                esp_mbedtls_psa_safer_memcmp(tag, check_tag, tag_length)
                 != 0) {
                 mbedtls_test_driver_aead_hooks.driver_status =
                     PSA_ERROR_INVALID_SIGNATURE;
diff --git a/tests/src/test_helpers/ssl_helpers.c b/tests/src/test_helpers/ssl_helpers.c
index 9a2ffcff090b75f39c88fb15e6ce40635d7e6c86..b714d2cd6ac50e254d4bfa4a09d4b2f66bf3138b 100644
--- a/tests/src/test_helpers/ssl_helpers.c
+++ b/tests/src/test_helpers/ssl_helpers.c
@@ -1950,13 +1950,13 @@ void mbedtls_test_ssl_perform_handshake(
         TEST_ASSERT(exchange_data(&(client.ssl), &(server.ssl)) == 0);
 
         TEST_ASSERT(client.ssl.out_buf_len ==
-                    mbedtls_ssl_get_output_buflen(&client.ssl));
+                    esp_mbedtls_ssl_get_output_buflen(&client.ssl));
         TEST_ASSERT(client.ssl.in_buf_len ==
-                    mbedtls_ssl_get_input_buflen(&client.ssl));
+                    esp_mbedtls_ssl_get_input_buflen(&client.ssl));
         TEST_ASSERT(server.ssl.out_buf_len ==
-                    mbedtls_ssl_get_output_buflen(&server.ssl));
+                    esp_mbedtls_ssl_get_output_buflen(&server.ssl));
         TEST_ASSERT(server.ssl.in_buf_len ==
-                    mbedtls_ssl_get_input_buflen(&server.ssl));
+                    esp_mbedtls_ssl_get_input_buflen(&server.ssl));
     }
 #endif
 
@@ -2015,9 +2015,9 @@ void mbedtls_test_ssl_perform_handshake(
         /* Validate buffer sizes after context deserialization */
         if (options->resize_buffers != 0) {
             TEST_ASSERT(server.ssl.out_buf_len ==
-                        mbedtls_ssl_get_output_buflen(&server.ssl));
+                        esp_mbedtls_ssl_get_output_buflen(&server.ssl));
             TEST_ASSERT(server.ssl.in_buf_len ==
-                        mbedtls_ssl_get_input_buflen(&server.ssl));
+                        esp_mbedtls_ssl_get_input_buflen(&server.ssl));
         }
 #endif
         /* Retest writing/reading */
@@ -2087,13 +2087,13 @@ void mbedtls_test_ssl_perform_handshake(
         /* Validate buffer sizes after renegotiation */
         if (options->resize_buffers != 0) {
             TEST_ASSERT(client.ssl.out_buf_len ==
-                        mbedtls_ssl_get_output_buflen(&client.ssl));
+                        esp_mbedtls_ssl_get_output_buflen(&client.ssl));
             TEST_ASSERT(client.ssl.in_buf_len ==
-                        mbedtls_ssl_get_input_buflen(&client.ssl));
+                        esp_mbedtls_ssl_get_input_buflen(&client.ssl));
             TEST_ASSERT(server.ssl.out_buf_len ==
-                        mbedtls_ssl_get_output_buflen(&server.ssl));
+                        esp_mbedtls_ssl_get_output_buflen(&server.ssl));
             TEST_ASSERT(server.ssl.in_buf_len ==
-                        mbedtls_ssl_get_input_buflen(&server.ssl));
+                        esp_mbedtls_ssl_get_input_buflen(&server.ssl));
         }
 #endif /* MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH */
     }
